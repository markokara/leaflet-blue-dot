<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Long Beach – Misafir Harita</title>

<link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet"/>
<script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
<!-- Turf.js: mesafe, bearing, nearestPointOnLine --><!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<title>Admin – Indoor/Outdoor/3D + Routes (Mapbox altta • OSM/3D üstte)</title>

<!-- OpenLayers -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v9.2.4/ol.css">
<script src="https://cdn.jsdelivr.net/npm/ol@v9.2.4/dist/ol.js"></script>

<!-- MapLibre (3D overlay) -->
<link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet">
<script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

<style>
  html,body{margin:0;height:100%;font-family:system-ui,Segoe UI,Roboto,Arial}

  /* Sıralama: Mapbox (OL) altta → OSM overlay (OL) → 3D overlay (MapLibre) → vektörler (OL) → UI */
  #map{position:fixed; inset:0; z-index:1; touch-action:none}
  #ml3d{position:fixed; inset:0; z-index:3; display:none; pointer-events:none} /* üstte şeffaf 3D katman */
  .ol-attribution{font-size:10px; opacity:.85}
  .ol-attribution button{display:none}

  .panel{position:fixed; left:50%; bottom:10px; transform:translateX(-50%); z-index:10;
    background:#fff; border-radius:12px; box-shadow:0 10px 24px rgba(0,0,0,.25);
    padding:10px; width:calc(100% - 20px); max-width:1180px;}
  .row{display:flex; flex-wrap:wrap; gap:8px}
  .row>*{flex:1 1 auto; min-width:120px}
  button,select,input[type="file"],input[type="text"],input[type="number"],input[type="range"]{
    padding:10px; border:1px solid #ddd; border-radius:10px; background:#fff; cursor:pointer}
  input[type="text"], input[type="number"], textarea{cursor:text}
  .primary{border-color:#b3d7ff; background:#f0f7ff}
  .active{outline:2px solid #3b82f6; background:#eaf2ff}
  .danger{border:1px solid #ffb3b3; background:#fff0f0}
  .pill{padding:4px 8px; font-size:12px; border-radius:999px; background:#eef2ff; border:1px solid #c7d2fe}
  .small{font-size:12px; color:#555}

  #status{position:fixed; top:10px; left:50%; transform:translateX(-50%); z-index:11;
    background:#111; color:#fff; padding:6px 10px; border-radius:8px; display:none; font-size:13px}
  .acc-badge{position:fixed; right:10px; top:10px; z-index:11; background:#fff; border:1px solid #ddd; border-radius:999px; padding:6px 10px; font-size:12px; box-shadow:0 4px 12px rgba(0,0,0,.15); display:none}

  /* yüzen toolbox */
  .toolbox {position:fixed; left:10px; top:70px; z-index:15; background:#fff; border:1px solid #ddd;
    border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,.18); display:none; flex-direction:column; gap:6px; padding:8px}
  .toolbox button{width:36px; height:36px; display:grid; place-items:center; border:1px solid #e5e7eb; border-radius:10px; background:#fff; cursor:pointer}
  .toolbox button:active{transform:translateY(1px)}

  .modal{position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:12}
  .panel2{background:#fff; width:min(780px,92vw); border-radius:14px; padding:14px; box-shadow:0 10px 28px rgba(0,0,0,.35)}
  .grid{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  .grid label{font-size:12px; color:#555}
  .grid input,.grid textarea,.grid select{width:100%; padding:10px; border:1px solid #ddd; border-radius:8px}
  textarea{min-height:72px}
  .actions{display:flex; gap:8px; justify-content:space-between; margin-top:10px}
  .actions .left{display:flex; gap:8px}

  @media (max-width: 640px){
    .panel{padding:8px}
    button,select,input[type="file"],input[type="text"],input[type="number"]{padding:9px; font-size:14px}
    .row>*{min-width:100px}
  }
</style>
</head>
<body>
<div id="map"></div>
<div id="ml3d"></div>
<div id="status"></div>
<div id="acc" class="acc-badge"></div>

<!-- TOOLBOX -->
<div class="toolbox" id="toolbox" title="Seçili öğe için araçlar">
  <button id="tbTranslate" title="Taşı (T)">↔️</button>
  <button id="tbCopy"      title="Kopyala (C)">📄</button>
  <button id="tbCircle"    title="Daireleştir (0)">⭕</button>
  <button id="tbSquare"    title="Kareleştir">◼️</button>
  <button id="tbFlipLong"  title="Uzun eksende çevir">⟂</button>
  <button id="tbFlipShort" title="Kısa eksende çevir">↕️</button>
  <button id="tbDelete"    title="Sil">🗑️</button>
</div>

<!-- KONTROLLER -->
<div class="panel">
  <div class="row" style="align-items:center">
    <label style="display:flex;align-items:center;gap:8px; flex:0 0 auto">
      <input id="mbBaseToggle" type="checkbox" checked> Mapbox uydu (altta)
    </label>
    <div style="display:flex;align-items:center;gap:8px; min-width:220px">
      <span class="small">Uydu opaklık</span>
      <input id="mbBaseOpacity" type="range" min="0" max="1" step="0.05" value="1.00" style="flex:1">
      <span id="mbBaseOpacityVal" class="small">1.00</span>
    </div>

    <label style="display:flex;align-items:center;gap:8px; flex:0 0 auto">
      <input id="osmOverlayToggle" type="checkbox" checked> OSM (üstte)
    </label>
    <div style="display:flex;align-items:center;gap:8px; min-width:220px">
      <span class="small">OSM opaklık</span>
      <input id="osmOverlayOpacity" type="range" min="0" max="1" step="0.05" value="0.40" style="flex:1">
      <span id="osmOverlayOpacityVal" class="small">0.40</span>
    </div>

    <label id="lbl3d" style="display:flex;align-items:center;gap:8px; flex:0 0 auto">
      <input id="ml3dToggle" type="checkbox"> 3D (MapLibre üstte)
    </label>
  </div>

  <div class="row" style="align-items:center">
    <select id="layerSel">
      <option value="outdoor">Hedef: OUTDOOR</option>
      <option value="indoor">Hedef: INDOOR</option>
      <option value="buildings">Hedef: 3D BİNA</option>
      <option value="routes">Hedef: YOLLAR</option>
    </select>
    <input id="levelFilter" placeholder="Kat filtresi (ör: 1) – boş=hepsi" />
    <button id="follow" class="primary" title="Konumumu izle">🎯 Takip: Kapalı</button>
    <span class="pill small">Aktif katman vurgulu</span>
  </div>

  <div class="row">
    <button id="addPoint"  class="primary">➕ Nokta</button>
    <button id="addLine"   class="primary">〰️ Çizgi</button>
    <button id="addPoly"   class="primary">⬛ Poligon</button>
    <button id="finishDraw" style="display:none">✔ Bitir</button>
    <button id="selectBtn">☑ Seç / Özellik</button>
    <button id="duplicateBtn" title="Seçili öğeyi kopyala (Ctrl+D)">📄 Kopyala</button>
    <label style="display:flex;align-items:center;gap:6px">
      <input type="checkbox" id="showArrows" checked> Yol yön okları
    </label>
  </div>

  <div class="row">
    <button id="expIndoor">⤓ indoor.json</button>
    <button id="expOutdoor">⤓ outdoor.json</button>
    <button id="expBuildings">⤓ buildings.json</button>
    <button id="expRoutes">⤓ routes.json</button>
    <label style="display:flex;align-items:center;gap:6px">⤒ JSON Yükle
      <input id="imp" type="file" accept=".json,application/json">
    </label>
    <button id="clearLocal" class="danger">🧹 Yerel Veriyi Temizle</button>
  </div>
</div>

<!-- ÖZELLİK FORMU -->
<div id="propModal" class="modal" aria-hidden="true">
  <div class="panel2">
    <h3>Özellikler</h3>
    <div class="grid">
      <div><label>İsim (varsayılan)</label><input id="f_name" placeholder="Örn: Ana Restoran"></div>
      <div>
        <label>Kategori</label>
        <select id="f_category">
          <option value="">Seçiniz…</option>
          <option>restaurant</option><option>bar</option><option>spa</option><option>pool</option>
          <option>wc</option><option>elevator</option><option>stair</option><option>kidsclub</option>
          <option>reception</option><option>shop</option><option>gym</option><option>beach</option>
          <option>shuttle</option><option>parking</option><option>gate</option><option>info</option>
          <option>building</option>
          <option>green</option><option>forest</option><option>garden</option><option>trees</option>
          <option>aquapark</option><option>waterslide</option><option>playground</option>
          <option>tennis</option><option>football</option><option>basketball</option><option>volleyball</option>
          <option>pier</option><option>beachbar</option><option>amphitheatre</option>
          <option>path</option><option>bike</option><option>service</option><option>noentry</option><option>oneway</option>
          <option value="_other">Diğer…</option>
        </select>
      </div>
      <div style="grid-column:1/-1; display:none" id="catOtherWrap"><label>Diğer Kategori</label><input id="f_category_other" placeholder="ör. lounge"></div>

      <div><label>Dolgu Rengi (fill)</label><input id="f_fill" type="text" placeholder="#09DCE4 veya 09DCE4"></div>
      <div><label>Çizgi Rengi (stroke)</label><input id="f_stroke" type="text" placeholder="#1f2937 veya 1f2937"></div>
      <div><label>Dolgu Opaklığı (0–1)</label><input id="f_fill_op" type="number" min="0" max="1" step="0.01" placeholder="örn: 0.25"></div>
      <div><label>Çizgi Opaklığı (0–1)</label><input id="f_stroke_op" type="number" min="0" max="1" step="0.01" placeholder="örn: 0.8"></div>

      <div><label>Çizgi Kalınlığı (px)</label><input id="f_width" type="number" step="0.5" min="0" placeholder="2"></div>
      <div><label>Yol Tipi</label>
        <select id="f_way">
          <option value="">(yok)</option>
          <option value="foot">Yaya</option>
          <option value="run">Koşu</option>
          <option value="indoor">Indoor koridor</option>
          <option value="bike">Bisiklet</option>
          <option value="shuttle">Shuttle</option>
          <option value="service">Servis/araç</option>
          <option value="no_entry">Girilmez</option>
          <option value="oneway_fwd">Tek yön (→)</option>
          <option value="oneway_rev">Tek yön (←)</option>
        </select>
      </div>

      <div style="grid-column:1/-1"><label>Emoji/İkon Metni</label><input id="f_icon_text" placeholder="ör. 🏊‍♂️"></div>

      <div><label>Seviye/Kat (varsayılan)</label><input id="f_level" placeholder="1"></div>
      <div><label>Saatler (varsayılan)</label><input id="f_hours" placeholder="09:00-22:00"></div>
      <div style="grid-column:1/-1"><label>Açıklama (varsayılan)</label><textarea id="f_desc" placeholder="Kısa açıklama veya https://... linkleri yaz; tıklanabilir."></textarea></div>
      <div style="grid-column:1/-1"><label>Fotoğraf/İkon URL</label><input id="f_image" placeholder="https://.../foto.png"></div>

      <div><label>Yükseklik (metre)</label><input id="f_height" type="number" min="0" step="0.5" placeholder="örn: 18"></div>
      <div><label>Kat Sayısı</label><input id="f_levels" type="number" min="0" step="1" placeholder="örn: 6"></div>

      <div><label>Öğe ID (otomatik)</label><input id="f_id" disabled></div>
      <div><label>Özet</label><input id="f_metric" disabled></div>
    </div>

    <hr style="margin:14px 0;border:none;border-top:1px solid #eee">

    <!-- Çok dilli -->
    <div class="grid">
      <div>
        <label>Dil</label>
        <select id="f_lang">
          <option value="tr">Türkçe</option><option value="en">English</option>
          <option value="ru">Русский</option><option value="de">Deutsch</option><option value="pl">Polski</option>
        </select>
      </div>
      <div class="pill small" style="align-self:end">Bu bölüm <b>name_XX / hours_XX / level_XX / desc_XX / image_XX</b> alanlarını yazar.</div>
    </div>
    <div class="grid">
      <div><label>İsim (seçili dil)</label><input id="l_name"></div>
      <div><label>Saatler (seçili dil)</label><input id="l_hours"></div>
      <div><label>Seviye/Kat (seçili dil)</label><input id="l_level"></div>
      <div style="grid-column:1/-1"><label>Açıklama (seçili dil)</label><textarea id="l_desc"></textarea></div>
      <div style="grid-column:1/-1"><label>Fotoğraf URL (seçili dil)</label><input id="l_image" placeholder="https://.../foto.jpg"></div>
    </div>

    <div class="actions">
      <div class="left">
        <button id="propGeom" class="pill">Geometriyi Düzenle</button>
        <button id="geomReset" class="pill">Düzenlemeyi Kapat</button>
        <button id="moveLayer" class="pill" style="display:none">Aktif katmana taşı</button>
        <button id="propDelete" class="danger">Sil</button>
      </div>
      <div>
        <button class="primary" id="propSave">Kaydet</button>
        <button class="primary" id="propClose">Kapat</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ====== TOKEN ====== */
const MAPBOX_TOKEN = "pk.eyJ1IjoiaWxnYXJpc2lrIiwiYSI6ImNtZTYyejdkYjBxMDQya3F0ZGxlbDEwcHYifQ.nGPeU6QDAVFW7MGF_i9-ug";

/* ====== yardımcılar ====== */
const $ = id => document.getElementById(id);
const statusEl = $("status");
const setStatus = (msg, ms=2200)=>{ if(!msg){statusEl.style.display="none";return;} statusEl.textContent=msg; statusEl.style.display="block"; if(ms>0) setTimeout(()=>statusEl.style.display="none", ms); };

const fmt = new ol.format.GeoJSON();
function isFC(gj){ return gj && gj.type==="FeatureCollection" && Array.isArray(gj.features); }

/* GEÇMİŞ: writeFeatures → JSON.parse ile çalışıyordu ve bazı ortamlarda geometri kaybı olabiliyordu.
   YENİ: writeFeaturesObject doğrudan JS nesnesi üretir; güvenli. */
const writeGJ = layer =>
  fmt.writeFeaturesObject(layer.getSource().getFeatures(), {
    featureProjection:"EPSG:3857",
    dataProjection:"EPSG:4326"
  });

const readGJToLayer = (layer, gj) => { if(!isFC(gj)) throw new Error("FeatureCollection bekleniyor"); const fs=fmt.readFeatures(gj,{featureProjection:"EPSG:3857",dataProjection:"EPSG:4326"}); layer.getSource().clear(); layer.getSource().addFeatures(fs); };

function debounce(fn, wait){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }
const saveLocalRaw = (k,d)=>{ try{ localStorage.setItem(k, JSON.stringify(d)); }catch(e){ alert("Yerel depolama dolu olabilir."); } };
const saveLocal = debounce((k,layer)=>{ saveLocalRaw(k, writeGJ(layer)); update3DBuildings(); }, 200);
const loadLocal = k => { const s=localStorage.getItem(k); try{return s?JSON.parse(s):null;}catch{return null;} };

function to4326(g){ return g.clone().transform('EPSG:3857','EPSG:4326'); }
function centerOf(g){ const e=g.getExtent(); return [(e[0]+e[2])/2,(e[1]+e[3])/2]; }
function validateImg(u){ if(!u) return true; try{ const x=new URL(u); if(!(x.protocol==="http:"||x.protocol==="https:")) return false; return /\.(jpg|jpeg|png|gif|webp|avif|svg)(\?.*)?$/i.test(x.pathname); }catch{ return false; } }
const clamp01 = v => Math.min(1, Math.max(0, v));

/* ====== renk yardımcıları ====== */
function hexToRGB(hex){
  const h=hex.replace('#','').trim(); if(!(h.length===3||h.length===6)) return null;
  const n = h.length===3 ? h.split('').map(c=>parseInt(c+c,16)) : [h.slice(0,2),h.slice(2,4),h.slice(4,6)].map(x=>parseInt(x,16));
  if(n.some(v=>isNaN(v))) return null; return {r:n[0],g:n[1],b:n[2]};
}
function withOpacity(color, alpha){
  if(!Number.isFinite(alpha)) return color;
  const a = clamp01(alpha);
  if(typeof color!=='string'||!color) return color;
  if(color.startsWith('#')){
    const rgb=hexToRGB(color); return rgb?`rgba(${rgb.r},${rgb.g},${rgb.b},${a})`:color;
  }
  const m = color.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)$/i);
  if(m){ return `rgba(${m[1]},${m[2]},${m[3]},${a})`; }
  return color;
}

/* ====== stiller ====== */
function arrowStylesFor(line, color="#111", count=4, size=10){
  const styles=[]; for(let i=1;i<=count;i++){ const t=i/(count+1); const p=line.getCoordinateAt(t);
    const prev=line.getCoordinateAt(Math.max(0,t-0.01)); const dx=p[0]-prev[0], dy=p[1]-prev[1];
    const rot=Math.atan2(dy,dx);
    styles.push(new ol.style.Style({ geometry:new ol.geom.Point(p),
      image:new ol.style.RegularShape({points:3, radius:size, rotation:rot, fill:new ol.style.Fill({color})}) }));
  } return styles;
}
function defaultFillStrokeForCategory(cat){
  switch(cat){
    case 'green': case 'garden': return {fill:'rgba(34,197,94,0.22)', stroke:'rgba(16,94,47,0.7)'};
    case 'forest': case 'trees': return {fill:'rgba(13,148,136,0.22)', stroke:'rgba(4,120,87,0.7)'};
    case 'aquapark': return {fill:'rgba(14,165,233,0.22)', stroke:'rgba(14,165,233,0.8)'};
    case 'waterslide': return {fill:'rgba(56,189,248,0.18)', stroke:'rgba(2,132,199,0.9)'};
    case 'playground': return {fill:'rgba(234,179,8,0.18)', stroke:'rgba(180,83,9,0.9)'};
    case 'tennis': return {fill:'rgba(74,222,128,0.18)', stroke:'rgba(22,163,74,0.9)'};
    case 'football': return {fill:'rgba(34,197,94,0.18)', stroke:'rgba(21,128,61,0.9)'};
    case 'basketball': return {fill:'rgba(250,204,21,0.18)', stroke:'rgba(202,138,4,0.9)'};
    case 'volleyball': return {fill:'rgba(253,186,116,0.18)', stroke:'rgba(234,88,12,0.9)'};
    case 'pool': return {fill:'rgba(59,130,246,0.2)', stroke:'rgba(37,99,235,0.9)'};
    default: return {fill:'rgba(0,150,0,0.18)', stroke:'rgba(0,0,0,0.6)'};
  }
}
function baseStyleFor(f, dim=1){
  const t=f.getGeometry().getType(); const p=f.getProperties()||{}; const cat=(p.category||'').toString();

  if(t==="Point"){
    const url=(p.image||'').trim(), txt=(p.icon_text||'').trim();
    if(url) return new ol.style.Style({ image:new ol.style.Icon({src:url, crossOrigin:'anonymous'}) });
    if(txt) return new ol.style.Style({ text:new ol.style.Text({ text:txt, font:"24px 'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',system-ui", fill:new ol.style.Fill({color:`rgba(0,0,0,${0.95*dim})`}) }) });
    return new ol.style.Style({ image:new ol.style.Circle({radius:6,fill:new ol.style.Fill({color:`rgba(200,0,0,${1*dim})`}),stroke:new ol.style.Stroke({color:"#fff",width:1.5})}) });
  }

  if(t==="LineString"){
    const way=(p.way||'').toString();
    const fallback =
      (way==='bike' ? '#22c55e' : way==='run' ? '#a855f7' : way==='shuttle' ? '#f59e0b' :
       way==='service' ? '#6b7280' : way==='indoor' ? '#0ea5e9' : way==='foot' ? '#1f2937' :
       way==='no_entry' ? '#ef4444' : '#1f2937');
    const baseCol = (p.stroke && p.stroke.trim()) ? p.stroke : fallback;
    const strokeCol = withOpacity(baseCol, Number.isFinite(p.stroke_op)? p.stroke_op : undefined);
    const w = Math.max(1, Number.isFinite(p.width)? p.width : (way==='shuttle'?4:(way==='bike'||way==='run'?3:2)));
    const dash = (way==='no_entry'? [6,6]: undefined);
    const styles=[ new ol.style.Style({ stroke:new ol.style.Stroke({color:strokeCol, width:w, lineDash:dash}) }) ];
    const showAr=$('showArrows').checked;
    const needsArrows = showAr && (['oneway_fwd','oneway_rev','shuttle','bike','indoor','foot','run'].includes(way));
    if(needsArrows){
      const ls=f.getGeometry(); const dir=(way==='oneway_rev')? ls.clone().reverse() : ls;
      styles.push(...arrowStylesFor(dir, strokeCol, 4, Math.max(8,w*2.2)));
    }
    return styles;
  }

  // Polygon
  const catDef=defaultFillStrokeForCategory(cat);
  const fillBase = p.fill || catDef.fill;
  const strokeBase = (p.stroke && p.stroke.trim()) ? p.stroke : catDef.stroke;
  const fillC = withOpacity(fillBase, Number.isFinite(p.fill_op)? p.fill_op : undefined);
  const strokeC = withOpacity(strokeBase, Number.isFinite(p.stroke_op)? p.stroke_op : undefined);
  const w=Math.max(1, Number.isFinite(p.width)?p.width:2);
  return new ol.style.Style({ fill:new ol.style.Fill({color:fillC}), stroke:new ol.style.Stroke({color:strokeC,width:w}) });
}

function buildingStyleFor(f, dim=1){
  const p=f.getProperties()||{};
  const baseStroke = (p.stroke && p.stroke.trim()) ? p.stroke : `rgba(120,84,48,${0.8*dim})`;
  const baseFill   = (p.fill && p.fill.trim())   ? p.fill   : `rgba(201,180,155,${0.25*dim})`;
  const strokeCol = withOpacity(baseStroke, Number.isFinite(p.stroke_op)? p.stroke_op : undefined);
  const fillCol   = withOpacity(baseFill,   Number.isFinite(p.fill_op)? p.fill_op   : undefined);
  if(f.getGeometry().getType()==="Point"){
    return new ol.style.Style({ image:new ol.style.Circle({radius:6,fill:new ol.style.Fill({color:fillCol}),stroke:new ol.style.Stroke({color:"#fff",width:1})}) });
  }
  return new ol.style.Style({stroke:new ol.style.Stroke({color:strokeCol,width:Math.max(1,p.width||2)}),fill:new ol.style.Fill({color:fillCol})});
}

function styleWrapper(name){
  return f=>{ const active=$("layerSel").value, filter=$("levelFilter").value.trim();
    const lvl=(f.get("level")??"").toString().trim(); const isActive=active===name;
    if(filter && lvl!==filter) return null;
    if(name==="buildings") return buildingStyleFor(f, isActive?1:0.35);
    return baseStyleFor(f, isActive?1:0.35);
  };
}

/* ====== katmanlar ====== */
const indoorLayer    = new ol.layer.VectorImage({source:new ol.source.Vector(), style:styleWrapper("indoor")});
const outdoorLayer   = new ol.layer.VectorImage({source:new ol.source.Vector(), style:styleWrapper("outdoor")});
const buildingsLayer = new ol.layer.VectorImage({source:new ol.source.Vector(), style:styleWrapper("buildings")});
const routesLayer    = new ol.layer.VectorImage({source:new ol.source.Vector(), style:styleWrapper("routes")});
[indoorLayer,outdoorLayer,buildingsLayer,routesLayer].forEach((l,i)=>l.setZIndex(20+i));
const tgtLayer = ()=>{ const v=$("layerSel").value; return v==="indoor"?indoorLayer : v==="outdoor"?outdoorLayer : v==="buildings"?buildingsLayer : routesLayer; };

/* Aktif/gerçek katman adını döndür */
function layerName(layer){
  if(layer===indoorLayer) return 'indoor';
  if(layer===outdoorLayer) return 'outdoor';
  if(layer===buildingsLayer) return 'buildings';
  if(layer===routesLayer) return 'routes';
  return null;
}
/* Bir feature şu anda hangi katmanda? */
function featureLayer(f){
  for(const L of [indoorLayer,outdoorLayer,buildingsLayer,routesLayer]){
    if(L.getSource().hasFeature(f)) return L;
  }
  return null;
}

/* ====== BASE: Mapbox (altta) + OSM overlay (üstte) ====== */
const lyrBaseMB = new ol.layer.Tile({
  source: new ol.source.XYZ({
    url:`https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/256/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`,
    crossOrigin:'anonymous',
    attributions:'© Mapbox © OpenStreetMap'
  }),
  opacity:1, zIndex:0, visible:true
});
const lyrOSMOverlay = new ol.layer.Tile({
  source:new ol.source.OSM({attributions:'© OpenStreetMap'}), opacity:0.40, zIndex:2, visible:true
});

/* ====== HARİTA ====== */
const map = new ol.Map({
  target:"map",
  layers:[lyrBaseMB, lyrOSMOverlay, indoorLayer, outdoorLayer, buildingsLayer, routesLayer],
  view:new ol.View({center: ol.proj.fromLonLat([31.005,36.861]), zoom:18})
});
map.addControl(new ol.control.Attribution({collapsible:false}));

/* ====== OSM/Mapbox UI ====== */
$("mbBaseToggle").onchange=()=> lyrBaseMB.setVisible($("mbBaseToggle").checked);
$("mbBaseOpacity").oninput=()=>{ const v=parseFloat($("mbBaseOpacity").value); lyrBaseMB.setOpacity(v); $("mbBaseOpacityVal").textContent=v.toFixed(2); };
$("osmOverlayToggle").onchange=()=> lyrOSMOverlay.setVisible($("osmOverlayToggle").checked);
$("osmOverlayOpacity").oninput=()=>{ const v=parseFloat($("osmOverlayOpacity").value); lyrOSMOverlay.setOpacity(v); $("osmOverlayOpacityVal").textContent=v.toFixed(2); };

/* ====== 3D MapLibre OVERLAY (şeffaf) ====== */
let mlMap=null, mlPitch=55, mlBearing=20;
function ensureML(){
  if(mlMap) return;
  const style={
    "version":8,
    "sources":{
      "bld":{"type":"geojson","data": loadLocal("buildings") || {"type":"FeatureCollection","features":[]}}
    },
    "layers":[
      {"id":"bld-ex","type":"fill-extrusion","source":"bld",
       "paint":{
         "fill-extrusion-color":["coalesce",["get","fill"],"#c9b49b"],
         "fill-extrusion-height":["coalesce",["to-number",["get","height"]],["*",["to-number",["coalesce",["get","levels"],["get","building:levels"],1]],3]],
         "fill-extrusion-opacity":0.95
       },
       "filter":["==",["geometry-type"],"Polygon"]
      }
    ],
    "glyphs":"https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
    "sprite":""
  };
  mlMap = new maplibregl.Map({
    container:"ml3d",
    style,
    interactive:false,
    center:[31.005,36.861],
    zoom:17,
    pitch:mlPitch,
    bearing:mlBearing,
    antialias:true,
    attributionControl:false
  });
}
function syncMLView(){
  if(!mlMap) return;
  const c=ol.proj.transform(map.getView().getCenter(),'EPSG:3857','EPSG:4326');
  const z=map.getView().getZoom();
  mlMap.jumpTo({center:[c[0],c[1]], zoom:Math.max(z-0.5, 3), pitch:mlPitch, bearing:mlBearing});
}
function update3DBuildings(){
  if(!mlMap) return;
  const src=mlMap.getSource('bld'); if(src && src.setData) src.setData(loadLocal("buildings") || {"type":"FeatureCollection","features":[]});
}
$("ml3dToggle").onchange=()=>{ const on=$("ml3dToggle").checked; if(on){ ensureML(); $("ml3d").style.display="block"; syncMLView(); } else { $("ml3d").style.display="none"; } };
map.getView().on(['change:center','change:resolution'], syncMLView);

/* ====== veri yükleme ====== */
(function initLoad(){
  readGJToLayer(indoorLayer,    loadLocal("indoor")    || {"type":"FeatureCollection","features":[]});
  readGJToLayer(outdoorLayer,   loadLocal("outdoor")   || {"type":"FeatureCollection","features":[]});
  readGJToLayer(buildingsLayer, loadLocal("buildings") || {"type":"FeatureCollection","features":[]});
  readGJToLayer(routesLayer,    loadLocal("routes")    || {"type":"FeatureCollection","features":[]});
})();

/* ====== konum + takip ====== */
const accEl=$("acc"); let userMarker=null, accCircle=null, userLayer=null, follow=false, watchId=null;
(function startWatch(){
  if(!("geolocation" in navigator)) return;
  try{ if(watchId!==null) navigator.geolocation.clearWatch(watchId);}catch{}
  watchId = navigator.geolocation.watchPosition(pos=>{
    const coords = ol.proj.fromLonLat([pos.coords.longitude,pos.coords.latitude]);
    if(!userMarker){
      userMarker = new ol.Feature(new ol.geom.Point(coords));
      userMarker.setStyle(new ol.style.Style({ image:new ol.style.Circle({radius:6, fill:new ol.style.Fill({color:"#007bff"}), stroke:new ol.style.Stroke({color:"#fff",width:2})}) }));
      accCircle  = new ol.Feature(new ol.geom.Circle(coords, pos.coords.accuracy||0));
      accCircle.setStyle(new ol.style.Style({ stroke:new ol.style.Stroke({color:"#007bff",width:1}), fill:new ol.style.Fill({color:"rgba(0,123,255,0.08)"}) }));
      userLayer  = new ol.layer.Vector({ source:new ol.source.Vector({features:[accCircle,userMarker]}) });
      userLayer.setZIndex(40); map.addLayer(userLayer);
    }else{
      userMarker.getGeometry().setCoordinates(coords); accCircle.getGeometry().setCenter(coords); accCircle.getGeometry().setRadius(pos.coords.accuracy||0);
    }
    accEl.textContent = "±" + Math.round(pos.coords.accuracy||0) + " m"; accEl.style.display="block";
    if(follow) map.getView().animate({center: coords, duration: 200});
  },()=>{}, { enableHighAccuracy:true, maximumAge:0, timeout:15000 });
})();
$("follow").onclick=()=>{ follow=!follow; $("follow").textContent = follow ? "🎯 Takip: Açık" : "🎯 Takip: Kapalı"; if(follow && userMarker) map.getView().setCenter(userMarker.getGeometry().getCoordinates()); };

/* ====== etkileşimler & toolbox ====== */
let mode=null, draw=null, select=null, selected=null, modify=null, snap=null, translate=null;
function resetInteractions(){
  if(draw){map.removeInteraction(draw);draw=null;}
  if(select){map.removeInteraction(select);select=null;}
  if(modify){map.removeInteraction(modify);modify=null;}
  if(snap){map.removeInteraction(snap);snap=null;}
  if(translate){map.removeInteraction(translate);translate=null; $("tbTranslate").classList.remove("active");}
  selected=null; mode=null;
  ["addPoint","addLine","addPoly","selectBtn"].forEach(id=>$(id).classList.remove("active"));
  $("finishDraw").style.display="none"; map.getTargetElement().style.cursor=""; $("toolbox").style.display="none";
}
function enableSnap(layer){ if(snap) map.removeInteraction(snap); snap=new ol.interaction.Snap({source:layer.getSource()}); map.addInteraction(snap); }

function enrich(f){
  try{ if(!f.getId() && crypto?.randomUUID) f.setId(crypto.randomUUID()); }catch{ }
  const g=f.getGeometry(), p=f.getProperties();
  if(g.getType()==="Polygon"){
    f.set("area_m2", Math.round(g.getArea()));
    if(p.category==="building" || $("layerSel").value==="buildings"){
      if(p.height==null){ const lv=parseInt(p.levels ?? p['building:levels'],10); if(Number.isFinite(lv)) f.set("height", lv*3); }
    }
  }else if(g.getType()==="LineString"){
    const ll = to4326(g).getCoordinates(); let len=0; for(let i=1;i<ll.length;i++) len += ol.sphere.getDistance(ll[i-1], ll[i]); f.set("len_m", Math.round(len));
  }
}
function toCircle(feature){ const g=feature.getGeometry(); if(!(g instanceof ol.geom.Polygon) && !(g instanceof ol.geom.LineString)) return;
  const c=centerOf(g); const coords=(g instanceof ol.geom.Polygon)? g.getCoordinates()[0] : g.getCoordinates();
  let r=0; coords.forEach(([x,y])=>{ r+=Math.hypot(x-c[0], y-c[1]); }); r/=Math.max(1,coords.length);
  feature.setGeometry(ol.geom.Polygon.fromCircle(new ol.geom.Circle(c, r||5), 64));
}
function toSquare(feature){ const g=feature.getGeometry(); if(!(g instanceof ol.geom.Polygon)) return;
  const e=g.getExtent(); feature.setGeometry(new ol.geom.Polygon([[[e[0],e[1]],[e[2],e[1]],[e[2],e[3]],[e[0],e[3]],[e[0],e[1]]]]));
}
function flipFeature(feature,longAxis=true){
  const g=feature.getGeometry(); const e=g.getExtent(); const cx=(e[0]+e[2])/2, cy=(e[1]+e[3])/2; const w=e[2]-e[0], h=e[3]-e[1];
  const fx = longAxis ? (w>=h) : !(w>=h); const fy = !fx; const mapPt=([x,y])=>[ fx?2*cx-x:x, fy?2*cy-y:y ];
  if(g instanceof ol.geom.Point){ g.setCoordinates(mapPt(g.getCoordinates())); }
  else if(g instanceof ol.geom.LineString){ g.setCoordinates(g.getCoordinates().map(mapPt)); }
  else if(g instanceof ol.geom.Polygon){ g.setCoordinates(g.getCoordinates().map(r=>r.map(mapPt))); }
}
function copyFeature(feature, layer){ const clone=feature.clone(); try{ clone.setId(crypto.randomUUID()); }catch{} const g=clone.getGeometry(); if(g && g.translate) g.translate(5,-5); layer.getSource().addFeature(clone); return clone; }

/* kaldır / çiz / seç */
map.on("singleclick",(evt)=>{ if(mode!=="point") return; const f=new ol.Feature(new ol.geom.Point(evt.coordinate)); enrich(f); tgtLayer().getSource().addFeature(f); openForm(f); saveLocal($("layerSel").value, tgtLayer()); });
$("addPoint").onclick=(e)=>{ e.preventDefault(); resetInteractions(); mode="point"; $("addPoint").classList.add("active"); setStatus("NOKTA: haritaya tıkla"); map.getTargetElement().style.cursor="crosshair"; };

$("addLine").onclick=(e)=>{ e.preventDefault(); resetInteractions(); mode="line"; $("addLine").classList.add("active"); setStatus("ÇİZGİ: noktaları yerleştir; çift tıkla bitir ya da ✔ Bitir"); map.getTargetElement().style.cursor="crosshair";
  const layer=tgtLayer(); draw=new ol.interaction.Draw({source:layer.getSource(),type:"LineString"}); map.addInteraction(draw); enableSnap(layer); $("finishDraw").style.display="inline-block"; $("finishDraw").onclick=()=>{ if(draw) draw.finishDrawing(); };
  draw.once("drawend",(ev)=>{ $("finishDraw").style.display="none"; enrich(ev.feature); openForm(ev.feature); saveLocal($("layerSel").value, layer); });
};
$("addPoly").onclick=(e)=>{ e.preventDefault(); resetInteractions(); mode="polygon"; $("addPoly").classList.add("active"); setStatus("POLİGON: noktaları yerleştir; çift tıkla bitir ya da ✔ Bitir"); map.getTargetElement().style.cursor="crosshair";
  const layer=tgtLayer(); draw=new ol.interaction.Draw({source:layer.getSource(),type:"Polygon"}); map.addInteraction(draw); enableSnap(layer); $("finishDraw").style.display="inline-block"; $("finishDraw").onclick=()=>{ if(draw) draw.finishDrawing(); };
  draw.once("drawend",(ev)=>{ $("finishDraw").style.display="none"; enrich(ev.feature); openForm(ev.feature); saveLocal($("layerSel").value, layer); });
};

$("selectBtn").onclick=(e)=>{
  e.preventDefault(); resetInteractions(); mode="select"; $("selectBtn").classList.add("active");
  setStatus("SEÇİM: öğeye tıkla → form & araçlar");
  const allLayers=[indoorLayer,outdoorLayer,buildingsLayer,routesLayer];
  select=new ol.interaction.Select({layers:allLayers}); if(select.setHitTolerance) select.setHitTolerance(6); map.addInteraction(select);
  select.on("select",ev=>{
    selected=ev.selected[0]||null; $("toolbox").style.display = selected ? "flex" : "none"; if(!selected) return;
    openForm(selected);
  });

  $("tbTranslate").onclick=()=>{ if(!selected) return;
    if(translate){ map.removeInteraction(translate); translate=null; $("tbTranslate").classList.remove("active"); }
    else{ translate = new ol.interaction.Translate({features: new ol.Collection([selected])}); map.addInteraction(translate); $("tbTranslate").classList.add("active");
      translate.on("translateend",()=>{ enrich(selected); saveLocal($("layerSel").value, tgtLayer()); }); }
  };
  $("tbCopy").onclick=()=>{ if(!selected) return; const c=copyFeature(selected, tgtLayer()); enrich(c); saveLocal($("layerSel").value, tgtLayer()); if(select){ select.getFeatures().clear(); select.getFeatures().push(c); selected=c; } };
  $("tbCircle").onclick=()=>{ if(!selected) return; toCircle(selected); enrich(selected); saveLocal($("layerSel").value, tgtLayer()); };
  $("tbSquare").onclick=()=>{ if(!selected) return; toSquare(selected); enrich(selected); saveLocal($("layerSel").value, tgtLayer()); };
  $("tbFlipLong").onclick=()=>{ if(!selected) return; flipFeature(selected,true); enrich(selected); saveLocal($("layerSel").value, tgtLayer()); };
  $("tbFlipShort").onclick=()=>{ if(!selected) return; flipFeature(selected,false); enrich(selected); saveLocal($("layerSel").value, tgtLayer()); };
  $("tbDelete").onclick=()=>{ if(!selected) return; if(confirm("Seçili öğe silinsin mi?")){ const L=featureLayer(selected) || tgtLayer(); L.getSource().removeFeature(selected); saveLocal(layerName(L), L); selected=null; $("toolbox").style.display="none"; } };
};
$("layerSel").addEventListener("change",()=>{ resetInteractions(); indoorLayer.changed(); outdoorLayer.changed(); buildingsLayer.changed(); routesLayer.changed(); });
$("levelFilter").addEventListener("input",()=>{ indoorLayer.changed(); outdoorLayer.changed(); routesLayer.changed(); buildingsLayer.changed(); });
$("showArrows").addEventListener("change",()=>{ routesLayer.changed(); });

/* ====== FORM + i18n ====== */
const modal=$("propModal");
let editFeature=null, i18nLang='tr';
function loadLangFields(p){ $('l_name').value=p['name_'+i18nLang]||''; $('l_hours').value=p['hours_'+i18nLang]||''; $('l_level').value=p['level_'+i18nLang]||''; $('l_desc').value=p['desc_'+i18nLang]||''; $('l_image').value=p['image_'+i18nLang]||''; }
function saveLangFields(p){
  const ln=i18nLang; const img=$('l_image').value.trim(); if(img && !validateImg(img)){ alert("Dil-özgü fotoğraf URL geçersiz."); return false; }
  p['name_'+ln]=$('l_name').value.trim()||undefined; p['hours_'+ln]=$('l_hours').value.trim()||undefined; p['level_'+ln]=$('l_level').value.trim()||undefined; p['desc_'+ln]=$('l_desc').value.trim()||undefined; p['image_'+ln]=img||undefined; return true;
}
function summarizeGeom(f){
  const g=f.getGeometry(), t=g.getType();
  if(t==="Point"){ const c=ol.proj.transform(g.getCoordinates(),'EPSG:3857','EPSG:4326'); return `Point · lon/lat: ${c[0].toFixed(6)}, ${c[1].toFixed(6)}`; }
  if(t==="LineString") return `LineString · uzunluk: ${f.get("len_m")||0} m`;
  if(t==="Polygon") return `Polygon · merkez: ${ol.proj.transform(centerOf(g),'EPSG:3857','EPSG:4326').map(n=>n.toFixed(6)).join(", ")} · alan ≈ ${(f.get("area_m2")||0)} m²`;
  return t;
}
function openForm(f){
  editFeature=f; const p=f.getProperties(); const catSel=$('f_category'), otherWrap=$('catOtherWrap'), other=$('f_category_other');
  $('f_name').value=p.name||""; $('f_hours').value=p.hours||""; $('f_level').value=p.level||""; $('f_desc').value=p.desc||""; $('f_image').value=p.image||""; $('f_id').value=f.getId()||""; $('f_metric').value=summarizeGeom(f);
  $('f_height').value=p.height??""; $('f_levels').value=p.levels??p['building:levels']??"";
  $('f_fill').value=p.fill||""; $('f_stroke').value=p.stroke||""; $('f_fill_op').value=(Number.isFinite(p.fill_op)?p.fill_op:""); $('f_stroke_op').value=(Number.isFinite(p.stroke_op)?p.stroke_op:"");
  $('f_width').value=(Number.isFinite(p.width)?p.width:"")||""; $('f_way').value=p.way||""; $('f_icon_text').value=p.icon_text||"";
  if(p.category && [...catSel.options].some(o=>o.value===p.category)){ catSel.value=p.category; otherWrap.style.display="none"; other.value=""; }
  else if(p.category){ catSel.value="_other"; otherWrap.style.display="block"; other.value=p.category; }
  else { catSel.value=""; otherWrap.style.display="none"; other.value=""; }
  catSel.onchange=()=>{ if(catSel.value==="_other") otherWrap.style.display="block"; else {otherWrap.style.display="none"; other.value="";} };
  $('f_lang').value=i18nLang; loadLangFields(p); $('f_lang').onchange=()=>{ i18nLang=$('f_lang').value; loadLangFields(editFeature.getProperties()); };

  modal.style.display="flex"; modal.setAttribute("aria-hidden","false");

  $('propSave').onclick=()=>{
    const img=$('f_image').value.trim(); if(img && !validateImg(img)){ alert("Fotoğraf URL geçersiz."); return; }
    const h=parseFloat($('f_height').value), lv=parseInt($('f_levels').value,10), width=parseFloat($('f_width').value);
    const fill_op = parseFloat($('f_fill_op').value), stroke_op = parseFloat($('f_stroke_op').value);
    const props={
      name:$('f_name').value.trim()||undefined,
      category:(catSel.value==="_other"? other.value.trim(): catSel.value.trim())||undefined,
      hours:$('f_hours').value.trim()||undefined,
      level:$('f_level').value.trim()||undefined,
      desc:$('f_desc').value.trim()||undefined,
      image:img||undefined,
      icon_text:($('f_icon_text').value||"").trim()||undefined,
      way:($('f_way').value||"").trim()||undefined,
      width:Number.isFinite(width)?width:undefined,
      stroke:(s=>{s=s.trim();return s?s.replace(/^#?/,'#'):undefined;})($('f_stroke').value),
      fill:(s=>{s=s.trim();return s?s.replace(/^#?/,'#'):undefined;})($('f_fill').value),
      stroke_op:Number.isFinite(stroke_op)? clamp01(stroke_op) : undefined,
      fill_op:Number.isFinite(fill_op)? clamp01(fill_op) : undefined,
      height:Number.isFinite(h)?h:undefined,
      levels:Number.isFinite(lv)?lv:undefined,
      'building:levels':Number.isFinite(lv)?lv:undefined
    };
    if((props.way==='foot'||props.way==='run'||props.way==='bike'||props.way==='shuttle'||props.way==='service'||props.way==='indoor') && !props.category){ props.category='path'; }
    if(!saveLangFields(props)) return;
    f.setProperties(props); enrich(f); // stil güncelle
    const L = featureLayer(f) || tgtLayer(); // hangi katmanda ise onu kaydet
    saveLocal(layerName(L), L);
    setStatus("Kaydedildi."); $('propClose').click();
  };
  $('propClose').onclick=()=>{ modal.style.display="none"; modal.setAttribute("aria-hidden","true"); };
  $('propGeom').onclick=()=>{ if(modify) map.removeInteraction(modify);
    modify=new ol.interaction.Modify({ features:new ol.Collection([f]) });
    map.addInteraction(modify); enableSnap(tgtLayer()); setStatus("DÜZENLEME: vertex taşı. 'Düzenlemeyi Kapat' ile çık.");
    modify.on("modifyend",()=>{ enrich(f); const L=featureLayer(f) || tgtLayer(); saveLocal(layerName(L), L); $('f_metric').value=summarizeGeom(f); });
  };
  $('geomReset').onclick=()=>{ if(modify){ map.removeInteraction(modify); modify=null; } if(snap){ map.removeInteraction(snap); snap=null; } setStatus("Geometri düzenleme kapatıldı."); };
  $('propDelete').onclick=()=>{ if(confirm("Bu öğe silinsin mi?")){ const L=featureLayer(f) || tgtLayer(); L.getSource().removeFeature(f); saveLocal(layerName(L), L); modal.style.display="none"; resetInteractions(); } };

  /* ==== YENİ: Aktif katmana taşı ==== */
  const moveBtn = $('moveLayer');
  const currLayer = featureLayer(f);
  const currName = layerName(currLayer);
  const actName  = $('layerSel').value;
  const actLayer = tgtLayer();

  if (currLayer && currLayer !== actLayer) {
    moveBtn.style.display = 'inline-block';
    moveBtn.textContent = `Taşı: ${actName.toUpperCase()}`;
    moveBtn.onclick = () => {
      currLayer.getSource().removeFeature(f);
      actLayer.getSource().addFeature(f);
      enrich(f);
      saveLocal(actName, actLayer);
      setStatus(`Öğe ${currName} → ${actName} taşındı.`);
      modal.style.display = 'none';
      resetInteractions();
    };
  } else {
    moveBtn.style.display = 'none';
    moveBtn.onclick = null;
  }
}

/* ====== indir / yükle / temizle ====== */
function dl(obj,name){ const b=new Blob([JSON.stringify(obj,null,2)],{type:"application/json"}); const u=URL.createObjectURL(b); const a=document.createElement("a"); a.href=u; a.download=name; a.click(); URL.revokeObjectURL(u); }
$("expIndoor").onclick=()=> dl(writeGJ(indoorLayer),"indoor.json");
$("expOutdoor").onclick=()=> dl(writeGJ(outdoorLayer),"outdoor.json");
$("expBuildings").onclick=()=> dl(writeGJ(buildingsLayer),"buildings.json");
$("expRoutes").onclick=()=> dl(writeGJ(routesLayer),"routes.json");

$("imp").addEventListener("change", async e=>{
  const file=e.target.files[0]; if(!file) return;
  if(file.size>10*1024*1024){ alert("Dosya > 10MB."); e.target.value=""; return; }
  try{ const json=JSON.parse(await file.text()); const layer=tgtLayer(); readGJToLayer(layer,json); saveLocal($("layerSel").value, layer); alert("GeoJSON yüklendi (aktif katmana)."); }
  catch(err){ console.error(err); alert("Geçersiz GeoJSON."); }
  e.target.value="";
});
$("clearLocal").onclick=()=>{
  if(!confirm("Yerel veriyi sil ve katmanları boşalt?")) return;
  ["indoor","outdoor","buildings","routes"].forEach(k=> localStorage.removeItem(k));
  indoorLayer.getSource().clear(); outdoorLayer.getSource().clear(); buildingsLayer.getSource().clear(); routesLayer.getSource().clear();
  indoorLayer.changed(); outdoorLayer.changed(); buildingsLayer.changed(); routesLayer.changed();
  update3DBuildings();
  setStatus("Yerel veri temizlendi.");
};
</script>
</body>
</html>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js" charset="utf-8"></script>

<style>
  :root{
    --shadow:0 10px 28px rgba(0,0,0,.18);
    --muted:#5b6a6a; --bg:#fff; --brand:#0f5132; --border:#cfe3da; --field:#f4fbf7; --chip:#e6f4ef;
  }
  html,body{height:100%;margin:0}
  body{font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#eaf4f0}
  #map{position:fixed; inset:0}

  .maplibregl-popup{ max-width:min(320px,86vw)!important; }
  .maplibregl-popup-content{ padding:10px 12px; overflow-wrap:anywhere; }
  .maplibregl-popup-content img{ width:100%; max-height:140px; height:auto; object-fit:cover; border-radius:8px; }
  @media (max-width:480px){ .maplibregl-popup-content{padding:9px 10px} }

  .lang-float{position:fixed; left:12px; top:12px; z-index:1200; background:#fff; border:1px solid var(--border); border-radius:12px; box-shadow:var(--shadow); padding:6px 8px}
  .lang-float select{border:1px solid var(--border); background:var(--field); border-radius:10px; padding:6px 8px}

  .panel{
    position:fixed; left:50%; bottom:0;
    transform:translate(-50%,var(--panel-ty,0px));
    transition:transform .2s ease;
    width:min(860px,96vw); z-index:1100
  }
  .card{background:#fff; border:1px solid var(--border); border-radius:16px; box-shadow:var(--shadow)}
  .p-8{padding:10px}
  .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
  .stack{display:flex; flex-direction:column; gap:10px}
  .grow{flex:1 1 auto}

  .grab{position:relative; width:64px; height:28px; margin:8px auto 0; cursor:grab}
  .grab::before,.grab::after{
    content:""; position:absolute; left:50%; transform:translateX(-50%);
    width:56px; height:6px; background:#9fd3b3; border-radius:999px; box-shadow:inset 0 0 0 1px #83c7a1;
  }
  .grab::before{ top:6px } .grab::after{ bottom:6px }

  input[type="search"]{width:100%; padding:11px 12px; border:1px solid var(--border); border-radius:12px; background:var(--field)}
  button{padding:9px 11px; border:1px solid var(--border); border-radius:12px; cursor:pointer; background:var(--field); white-space:nowrap}
  button:active{transform:translateY(1px)}
  .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid var(--border); border-radius:999px; background:var(--chip); font-size:13px}
  .chip input{accent-color:#1b7a5b}
  .chip .tick{opacity:.18; transition:.15s}
  .chip input:checked ~ .tick{opacity:1}

  .results{background:#fff; border:1px solid var(--border); border-radius:12px; max-height:36vh; overflow:auto; position:relative; z-index:2001; display:none; -webkit-overflow-scrolling:touch}
  .results .item{display:flex; justify-content:space-between; gap:8px; padding:10px 12px; cursor:pointer}
  .results .item:hover{background:#f1f7f4}
  .results .hint{padding:8px 12px; color:var(--muted); font-size:12px; pointer-events:none}

  .dir{display:none; background:#fff; border:1px solid var(--border); border-radius:12px}
  .dir .hdr{display:flex; justify-content:space-between; align-items:center; padding:10px 12px; border-bottom:1px solid #e5efe9}
  .dir .list{max-height:30vh; overflow:auto; padding:8px 12px}

  .badge{display:inline-block; padding:.2rem .5rem; border-radius:999px; background:#edf7f3; border:1px solid var(--border); font-size:12px}
  .acc{position:fixed; right:12px; bottom:12px; z-index:1005; background:#fff; border:1px solid var(--border); border-radius:999px; padding:6px 10px; font-size:12px; box-shadow:var(--shadow)}
  @media (max-width:520px){ .panel{bottom:8px} }

  .row.searchrow{display:grid; grid-template-columns:1fr auto; gap:8px}
  .row.ctlsB .chip{padding:6px 10px}
  .muted{color:var(--muted)}
</style>
</head>
<body>

<!-- Dil -->
<div class="lang-float">
  <select id="lang" aria-label="Dil">
    <option value="tr" selected>TR</option><option value="en">EN</option>
    <option value="ru">RU</option><option value="de">DE</option><option value="pl">PL</option>
  </select>
</div>

<div id="map" aria-label="Harita"></div>

<!-- Bottom sheet -->
<div class="panel" id="sheet">
  <div class="card">
    <div class="grab" id="grab"></div>
    <div class="p-8 stack" id="sheetContent">

      <div class="row searchrow">
        <input id="q" class="grow" type="search" placeholder="Ara: restoran, spa, havuz…"/>
        <button id="go" title="Seçili hedefe rota" disabled>Git</button>
      </div>

      <div class="row ctlsB">
        <button id="pickStart">Başlangıç Seç</button>
        <button id="pickDest">Hedef Seç</button>
        <button id="follow">📍 Konumum: Kapalı</button>
        <button id="reset">Sıfırla</button>
        <span class="grow"></span>
        <label class="chip" title="Satellite (raster)">
          <input type="radio" name="basemap" id="baseSat" checked><span>Satellite</span><span class="tick">✓</span>
        </label>
        <label class="chip" title="MapLibre 3D (terrain + binalar)">
          <input type="radio" name="basemap" id="base3d"><span>MapLibre 3D</span><span class="tick">✓</span>
        </label>

        <!-- DEBUG SEÇENEKLERİ -->
        <label class="chip" title="Debug: Bileşenleri renklendir">
         <input type="checkbox" id="dbgComps"><span>Debug: Bileşenler</span><span class="tick">✓</span>
          </label>
          <label class="chip" title="Debug: Snap noktalarını ve segmanlarını göster">
          <input type="checkbox" id="dbgSnaps"><span>Snap</span><span class="tick">✓</span>
          </label>
        <label class="chip" title="Debug: Dead-end düğümler">
  <input type="checkbox" id="dbgDead"><span>Dead-ends</span><span class="tick">✓</span>
        </label>











        <!-- PROFİL SEÇİMİ -->
        <label class="chip" title="Yaya">
          <input type="radio" name="profile" value="walk" checked><span>Yaya</span><span class="tick">✓</span>
        </label>
        <label class="chip" title="Bisiklet">
          <input type="radio" name="profile" value="bike"><span>Bisiklet</span><span class="tick">✓</span>
        </label>
        <label class="chip" title="Shuttle">
          <input type="radio" name="profile" value="shuttle"><span>Shuttle</span><span class="tick">✓</span>
        </label>
      </div>

      <div id="results" class="results"></div>

      <div id="dir" class="dir">
        <div class="hdr">
          <div><span class="sum" id="dirSum">–</span> <span class="muted" id="dirSub"></span></div>
          <div class="row">
            <button id="collapseDir">▲</button>
            <button id="clearRoute">Rota Temizle</button>
          </div>
        </div>
        <div class="list" id="dirList"></div>
      </div>

      <div class="muted" style="font-size:11px; text-align:right">© aihotelstech · © OpenStreetMap contributors · © MapTiler · © Mapbox</div>
    </div>
  </div>
</div>

<div id="acc" class="acc" style="display:none"></div>

<script>
/* ================== ANAHTARLAR ================== */
const MAPBOX_TOKEN = "pk.eyJ1IjoiaWxnYXJpc2lrIiwiYSI6ImNtZTYyejdkYjBxMDQya3F0ZGxlbDEwcHYifQ.nGPeU6QDAVFW7MGF_i9-ug";
const MAPTILER_KEY = "ym4UWHwsNK61YUsmqi5C";

/* ================== AYARLAR ================== */
const HOTEL_BBOX = [31.801445, 36.597411, 31.808467, 36.600917]; // Long Beach
const PADDING = {top:120,right:16,bottom:160,left:16};
const DEFAULT_PITCH = 45, DEFAULT_BEARING = 0;

const OSM_OPACITY = 0.25;
const OSM_VISIBLE = true;

/* ===== SİMÜLASYON: sabit bluedot ===== */
const SIMULATE_ME   = false; // true: simule et, false: gerçek GPS  
const SIM_ME_COORD  = [31.005858, 36.862770];
const SIM_ME_ACC_M  = 5;

/* ===== ROTA BAĞLANTI (connector) EŞİKLERİ ===== */
const MAX_CONNECTOR_M     = 50; // >50 m ise rota yapma ve uyar
const HIDE_CONNECTOR_LT_M = 5;  // <5 m ise connector’ı çizme (gizle)


/* ================== i18n ================== */
const I18N = {
  tr:{searchPH:"Ara: restoran, spa, havuz…", go:"Git",
      ui:{pickStart:"Başlangıç Seç", pickDest:"Hedef Seç", followOn:"📍 Konumum: Açık", followOff:"📍 Konumum: Kapalı", reset:"Sıfırla", clearRoute:"Rota Temizle"},
      labels:{name:"İsim", category:"Tür", hours:"Saat", level:"Kat", desc:"Açıklama"},
      cats:{pool:"Havuz", restaurant:"Restoran", spa:"Spa", bar:"Bar", cafe:"Kafe", shop:"Dükkan", toilet:"WC", reception:"Resepsiyon", beach:"Plaj", kidsclub:"Çocuk Kulübü", elevator:"Asansör", gate:"Kapı", parking:"Otopark", shuttle:"Servis", gym:"Spor Salonu"},
      nav:{depart:"Başla", arrive:"Varış", turn_left:"Sola dön", turn_right:"Sağa dön", straight:"Düz devam", roundabout:"Göbekte %n. çıkış", onto:" → %s"}
  },
  en:{searchPH:"Search: restaurant, spa, pool…", go:"Go",
      ui:{pickStart:"Pick Start", pickDest:"Pick Destination", followOn:"📍 My Location: On", followOff:"📍 My Location: Off", reset:"Reset", clearRoute:"Clear Route"},
      labels:{name:"Name", category:"Type", hours:"Hours", level:"Level", desc:"Description"},
      cats:{pool:"Pool", restaurant:"Restaurant", spa:"Spa", bar:"Bar", cafe:"Cafe", shop:"Shop", toilet:"Toilet", reception:"Reception", beach:"Beach", kidsclub:"Kids Club", elevator:"Elevator", gate:"Gate", parking:"Parking", shuttle:"Shuttle", gym:"Gym"},
      nav:{depart:"Depart", arrive:"Arrive", turn_left:"Turn left", turn_right:"Turn right", straight:"Go straight", roundabout:"At roundabout take exit %n", onto:" onto %s"}
  },
  de:{searchPH:"Suche: Restaurant, Spa, Pool…", go:"Los",
      ui:{pickStart:"Start wählen", pickDest:"Ziel wählen", followOn:"📍 Mein Standort: An", followOff:"📍 Mein Standort: Aus", reset:"Zurücksetzen", clearRoute:"Route löschen"},
      labels:{name:"Name", category:"Typ", hours:"Öffnungszeiten", level:"Etage", desc:"Beschreibung"},
      cats:{pool:"Pool", restaurant:"Restaurant", spa:"Spa/Wellness", bar:"Bar", cafe:"Café", shop:"Shop", toilet:"Toilette", reception:"Rezeption", beach:"Strand", kidsclub:"Kinderclub", elevator:"Aufzug", gate:"Eingangstor", parking:"Parkplatz", shuttle:"Shuttle", gym:"Fitnessstudio"},
      nav:{depart:"Start", arrive:"Ankunft", turn_left:"Links abbiegen", turn_right:"Rechts abbiegen", straight:"Geradeaus", roundabout:"Im Kreisverkehr Ausfahrt %n nehmen", onto:" auf %s"}
  },
  ru:{searchPH:"Поиск: ресторан, спа, бассейн…", go:"Поехали",
      ui:{pickStart:"Выбрать старт", pickDest:"Выбрать пункт", followOn:"📍 Моё местоположение: Вкл", followOff:"📍 Моё местоположение: Выкл", reset:"Сброс", clearRoute:"Очистить маршрут"},
      labels:{name:"Название", category:"Тип", hours:"Часы", level:"Этаж", desc:"Описание"},
      cats:{pool:"Бассейн", restaurant:"Ресторан", spa:"Спа", bar:"Бар", cafe:"Кафе", shop:"Магазин", toilet:"Туалет", reception:"Ресепшен", beach:"Пляж", kidsclub:"Детский клуб", elevator:"Лифт", gate:"Вход/ворота", parking:"Парковка", shuttle:"Шаттл", gym:"Спортзал"},
      nav:{depart:"Начать", arrive:"Прибытие", turn_left:"Поверните налево", turn_right:"Поверните направо", straight:"Двигайтесь прямо", roundabout:"На круговом съезде — съезд №%n", onto:" на %s"}
  },
  pl:{searchPH:"Szukaj: restauracja, spa, basen…", go:"Jedź",
      ui:{pickStart:"Wybierz start", pickDest:"Wybierz cel", followOn:"📍 Moja lokalizacja: Wł", followOff:"📍 Moja lokalizacja: Wył", reset:"Resetuj", clearRoute:"Wyczyść trasę"},
      labels:{name:"Nazwa", category:"Typ", hours:"Godziny", level:"Poziom", desc:"Opis"},
      cats:{pool:"Basen", restaurant:"Restauracja", spa:"Spa", bar:"Bar", cafe:"Kawiarnia", shop:"Sklep", toilet:"Toaleta", reception:"Recepcja", beach:"Plaża", kidsclub:"Klub dziecięcy", elevator:"Winda", gate:"Brama/Wejście", parking:"Parking", shuttle:"Shuttle", gym:"Siłownia"},
      nav:{depart:"Start", arrive:"Meta", turn_left:"Skręć w lewo", turn_right:"Skręć w prawo", straight:"Jedź prosto", roundabout:"Na rondzie zjedź zjazdem nr %n", onto:" na %s"}
  }
};
const SUP_LANGS = ['tr','en','ru','de','pl'];
let LANG = localStorage.getItem("lang");
if (!LANG) {
  const nav = (navigator.language || navigator.userLanguage || 'en').slice(0,2).toLowerCase();
  LANG = SUP_LANGS.includes(nav) ? nav : 'en';
  localStorage.setItem('lang', LANG);
}
const t = () => I18N[LANG] || I18N.tr;
const norm = s => (s||'').toString().toLowerCase().normalize('NFD').replace(/[̀-ͯ]/g,'');

/* Profiller (m/sn hızlar) */
const SPEEDS = { walk: 1.35, bike: 4.5, shuttle: 7.0 };
let CURRENT_PROFILE = 'walk';

/* ================== MAP ================== */
const baseStyle = {version:8, glyphs:`https://api.maptiler.com/fonts/{fontstack}/{range}.pbf?key=${MAPTILER_KEY}`, sources:{}, layers:[{id:"bg",type:"background",paint:{"background-color":"#dfe7e7"}}]};
const map = new maplibregl.Map({ container:'map', style:baseStyle, center:[(HOTEL_BBOX[0]+HOTEL_BBOX[2])/2,(HOTEL_BBOX[1]+HOTEL_BBOX[3])/2], zoom:16, pitch:DEFAULT_PITCH, bearing:DEFAULT_BEARING, maxZoom:21, attributionControl:false });
map.addControl(new maplibregl.NavigationControl({visualizePitch:true}), 'top-right');
map.addControl(new maplibregl.AttributionControl({customAttribution:'© aihotelstech'}));

/* DOM */
const $=id=>document.getElementById(id);
const langSel=$('lang'), q=$('q'), goBtn=$('go'), pickStartBtn=$('pickStart'), pickDestBtn=$('pickDest'), followBtn=$('follow'), resetBtn=$('reset'), results=$('results'), acc=$('acc');
const dirBox=$('dir'), dirSum=$('dirSum'), dirSub=$('dirSub'), dirList=$('dirList'), collapseDir=$('collapseDir'), clearRouteBtn=$('clearRoute');
const baseSat=$('baseSat'), base3d=$('base3d');
const searchRow = document.querySelector('.row.searchrow');
const ctlsRow   = document.querySelector('.row.ctlsB'); 

function setMode(mode){            // 'search' | 'route'
  const isRoute = mode === 'route';
  // Search alanı + kontrol çipleri
  searchRow.style.display = isRoute ? 'none'  : 'grid';
  ctlsRow.style.display   = isRoute ? 'none'  : 'flex';
  // Rota alanı
  dirBox.style.display    = isRoute ? 'block' : 'none';
}



/* State */
let allFeats=[], followState=false, lastKnown=null;
let pickMode='none'; // 'start' | 'dest' | 'none'
let startCoord=null, destCoord=null;

/* Profiller dinleyici */
document.querySelectorAll('input[name="profile"]').forEach(r=>{
  r.addEventListener('change', ()=> CURRENT_PROFILE = r.value);
});

/* Helpers */
function emptyFC(){return {type:'FeatureCollection',features:[]};}
function linkify(text){ return (text||'').replace(/(https?:\/\/[^\s<>"']+)/g,'<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'); }
function nameInAnyLang(p){ return p['name_'+LANG] || p.name || p.name_tr || p.name_en || p.name_ru || p.name_de || p.name_pl || ''; }

/* LOAD */
map.on('load', async ()=>{
  // Satellite (altta)
  map.addSource('sat',{ type:'raster',
    tiles:[`https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/256/{z}/{x}/{y}@2x?access_token=${MAPBOX_TOKEN}`],
    tileSize:256, attribution:"© Mapbox © OSM"
  });
  map.addLayer({id:'sat-lyr', type:'raster', source:'sat'});

  // OSM raster ÜSTTE
  map.addSource('osmRaster',{ type:'raster',
    tiles:[`https://api.maptiler.com/maps/streets/256/{z}/{x}/{y}.png?key=${MAPTILER_KEY}`],
    tileSize:256, attribution:"© OpenMapTiles © OpenStreetMap contributors"
  });
  map.addLayer({id:'osm-raster', type:'raster', source:'osmRaster',
    paint:{'raster-opacity': OSM_VISIBLE ? OSM_OPACITY : 0}});
    // DEBUG kaynak
map.addSource('debug', {type:'geojson', data:{type:'FeatureCollection',features:[]}});
// Bileşenleri renklendirilmiş edge’ler
map.addLayer({id:'dbg-comps', type:'line', source:'debug',
  filter:['==',['get','kind'],'edge'],
  paint:{
    // comp id'ye göre pastel renk
    'line-color': ['interpolate',['linear'],['coalesce',['to-number',['get','comp']],0],
      0,'#7dd3fc', 5,'#a78bfa', 10,'#f472b6', 15,'#34d399', 20,'#f59e0b', 25,'#60a5fa'],
    'line-width': 3,
    'line-opacity': 0.7
  }
});
 // Snap noktaları
map.addLayer({id:'dbg-snap', type:'circle', source:'debug',
  filter:['==',['get','kind'],'snap'],
  paint:{'circle-radius':6,'circle-color':'#ef4444','circle-stroke-color':'#fff','circle-stroke-width':1.5}
});
 // Snap edilen A–B segmentleri (kesik kırmızı)
map.addLayer({id:'dbg-seg', type:'line', source:'debug',
  filter:['==',['get','kind'],'seg'],
  paint:{'line-color':'#ef4444','line-width':3,'line-dasharray':[1,1]}
});
 // Dead-end düğümler
map.addLayer({id:'dbg-dead', type:'circle', source:'debug',
  filter:['==',['get','kind'],'dead'],
  paint:{'circle-radius':4,'circle-color':'#000','circle-stroke-color':'#fff','circle-stroke-width':1}
});


  // 3D
  map.addSource('omt',{ type:'vector', url:`https://api.maptiler.com/tiles/v3/tiles.json?key=${MAPTILER_KEY}` });
  map.addSource('dem',{ type:'raster-dem', url:`https://api.maptiler.com/tiles/terrain-rgb/tiles.json?key=${MAPTILER_KEY}`, tileSize:256 });
  map.addLayer({ id:'bldg-3d', type:'fill-extrusion', source:'omt', 'source-layer':'building', layout:{visibility:'none'},
    paint:{'fill-extrusion-color':'#b9c9d6','fill-extrusion-opacity':0.85,'fill-extrusion-height':['coalesce', ['to-number',['get','render_height']], ['to-number',['get','height']], 6],'fill-extrusion-base':['coalesce', ['to-number',['get','render_min_height']], ['to-number',['get','min_height']], 0]}, minzoom:14 });

  // POI/çizimler
  map.addSource('indoor',{type:'geojson', data:emptyFC(), promoteId:'fid'});
  map.addSource('outdoor',{type:'geojson', data:emptyFC(), promoteId:'fid'});
  map.addSource('routes',{type:'geojson', data:emptyFC(), promoteId:'fid'}); // ROUTES ağı

  addFeatureLayers('indoor'); addFeatureLayers('outdoor');

  // ROUTES görünümü
  map.addLayer({id:'routes-casing', type:'line', source:'routes',
    paint:{'line-color':'#ffffff','line-width':['+',['coalesce',['to-number',['get','width']],['to-number',['get','stroke_w']],2.4],2],'line-opacity':0.6},
    layout:{'line-cap':'round','line-join':'round'}, minzoom:10
  });
  map.addLayer({id:'routes-net', type:'line', source:'routes',
    paint:{
      'line-color': ['coalesce',['get','stroke'], ['get','fill'], '#6c9f90'],
      'line-width' : ['coalesce',['to-number',['get','width']],['to-number',['get','stroke_w']],['to-number',['get','stroke-width']],2.4],
      'line-opacity': ['coalesce', ['to-number',['get','stroke_op']], 1]
    },
    layout:{'line-cap':'round','line-join':'round'}, minzoom:10
  });

  // hedef/rota/bluedot/start
  map.addSource('start',{type:'geojson',data:emptyFC()});
  map.addLayer({id:'start-pt',type:'circle',source:'start',paint:{'circle-radius':7,'circle-color':'#22c55e','circle-stroke-color':'#fff','circle-stroke-width':1.8}});

  map.addSource('dest',{type:'geojson',data:emptyFC()});
  map.addLayer({id:'dest-pt',type:'circle',source:'dest',paint:{'circle-radius':7,'circle-color':'#ef4444','circle-stroke-color':'#fff','circle-stroke-width':1.8}});

  map.addSource('route',{type:'geojson',data:emptyFC()});
  // Ana rota (yeşil)
  map.addLayer({id:'route-line',type:'line',source:'route',
    paint:{'line-color':'#1b7a5b','line-width':4}, layout:{'line-cap':'round','line-join':'round'},
    filter:['==',['get','role'],'main']
  });
  // Bağlayıcılar (kesik)
  map.addLayer({id:'route-connector',type:'line',source:'route',
    paint:{'line-color':'#94a3b8','line-width':3,'line-dasharray':[2,2]}, layout:{'line-cap':'round','line-join':'round'},
    filter:['==',['get','role'],'connector']
  });
  // Oklar sadece ana rotada
  map.addLayer({id:'route-arrows',type:'symbol',source:'route',
    layout:{'symbol-placement':'line','text-field':'▶','text-size':12,'symbol-spacing':50,'text-rotation-alignment':'map','text-keep-upright':false},
    paint:{'text-color':'#1b7a5b','text-halo-color':'#fff','text-halo-width':1},
    filter:['==',['get','role'],'main']
  });

  // BLUEDOT
  map.addSource('me',{type:'geojson',data:emptyFC()});
  map.addLayer({id:'me-pt',type:'circle',source:'me',paint:{'circle-radius':6,'circle-color':'#1d4ed8','circle-stroke-color':'#fff','circle-stroke-width':1.6}});

  await loadJSONs();
  applyLang();
  applyBasemap();
  map.fitBounds([[HOTEL_BBOX[0],HOTEL_BBOX[1]],[HOTEL_BBOX[2],HOTEL_BBOX[3]]],{padding:PADDING,maxZoom:19,pitch:DEFAULT_PITCH,bearing:DEFAULT_BEARING});
});

/* Katman yardımcıları */
function addFeatureLayers(src){
  map.addLayer({id:`${src}-fill`,type:'fill',source:src,paint:{'fill-color':['coalesce',['get','fill'],'#2563eb'],'fill-opacity':['coalesce',['get','fill_op'],0.35]}});
  map.addLayer({id:`${src}-fill-outline`,type:'line',source:src,filter:['==',['geometry-type'],'Polygon'],paint:{'line-color':['coalesce',['get','stroke'],'#2563eb'],'line-width':['coalesce',['get','stroke_w'],1.6]}});
  map.addLayer({id:`${src}-line`,type:'line',source:src,filter:['==',['geometry-type'],'LineString'],paint:{'line-color':['coalesce',['get','stroke'],'#2563eb'],'line-width':['coalesce',['get','stroke_w'],2.5]}});
  map.addLayer({id:`${src}-pts`,type:'circle',source:src,filter:['==',['geometry-type'],'Point'],paint:{'circle-radius':['coalesce',['get','icon_sz'],6],'circle-color':['coalesce',['get','stroke'],'#e53935'],'circle-stroke-color':'#fff','circle-stroke-width':1.6}});
}

/* JSON yükleme */
async function loadJSONs(){
  const bust='v='+Date.now();
  const [rawIndoor, rawOutdoor, routes] = await Promise.all([
    fetch('indoor.json?'+bust,{cache:'no-store'}).then(safeJson).catch(errLog('indoor')),
    fetch('outdoor.json?'+bust,{cache:'no-store'}).then(safeJson).catch(errLog('outdoor')),
    fetch('routes.json?'+bust,{cache:'no-store'}).then(safeJson).catch(errLog('routes'))
  ]);

  const indoor  = ensureFid(rawIndoor,  'in');
  const outdoor = ensureFid(rawOutdoor, 'out');

  map.getSource('indoor').setData(indoor||emptyFC());
  map.getSource('outdoor').setData(outdoor||emptyFC());

  const validRoutes = validateRoutes(routes) ? routes : emptyFC();
  map.getSource('routes').setData(validRoutes);

  const indoorFs = (indoor?.features||[]).map(f=>({...f,__src:'indoor'}));
  const outdoorFs = (outdoor?.features||[]).map(f=>({...f,__src:'outdoor'}));
  allFeats = indoorFs.concat(outdoorFs);

  // Rota grafı (METRE + mod kısıtlı)
  buildRouteGraph(validRoutes);

  autoZoomToRoutes(validRoutes);
}

function ensureFid(fc, prefix){
  if(!fc || !Array.isArray(fc.features)) return fc;
  fc.features.forEach((f,i)=>{ if(!f.properties) f.properties={}; if(!f.properties.fid) f.properties.fid=`${prefix}-${i}-${(f.id||'x')}`; });
  return fc;
}
function validateRoutes(fc){
  if(!fc || fc.type!=='FeatureCollection'){ console.warn('routes.json FeatureCollection değil'); return false; }
  const hasLS = (fc.features||[]).some(f=>f.geometry && f.geometry.type==='LineString');
  if(!hasLS){ console.warn('routes.json içinde LineString yok'); return false; }
  return true;
}
function autoZoomToRoutes(fc){
  const f = (fc.features||[]).filter(g=>g.geometry && g.geometry.type==='LineString');
  if(!f.length) return;
  let minX= Infinity, minY= Infinity, maxX= -Infinity, maxY= -Infinity;
  f.forEach(ft=>{ (ft.geometry.coordinates||[]).forEach(([x,y])=>{ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; }); });
  if(!isFinite(minX)) return;
  const curr = map.getBounds();
  const intersects = !(maxX<curr.getWest() || minX>curr.getEast() || maxY<curr.getSouth() || minY>curr.getNorth());
  if(!intersects) map.fitBounds([[minX,minY],[maxX,maxY]], {padding:PADDING, maxZoom:18});
}
function safeJson(r){ if(!r.ok) throw new Error('HTTP '+r.status); return r.json(); }
function errLog(tag){ return e=>{ console.error(`[${tag}.json] yüklenemedi:`, e?.message||e); return emptyFC(); } }

/* ================== BASMAP TOGGLE ================== */
baseSat.addEventListener('change', applyBasemap);
base3d.addEventListener('change', applyBasemap);
function applyBasemap(){
  const osmOpacity = OSM_VISIBLE ? OSM_OPACITY : 0;
  if(base3d.checked){
    map.setLayoutProperty('bldg-3d','visibility','visible');
    map.setTerrain({source:'dem', exaggeration:1});
    if(!map.getLayer('sky')){
      map.addLayer({ id:'sky', type:'sky', paint:{'sky-type':'atmosphere','sky-atmosphere-sun':[0,45],'sky-atmosphere-sun-intensity':10} });
    }
  }else{
    if(map.getLayer('sky')) map.removeLayer('sky');
    map.setTerrain(null);
    map.setLayoutProperty('bldg-3d','visibility','none');
  }
  if(map.getLayer('osm-raster')) map.setPaintProperty('osm-raster','raster-opacity',osmOpacity);
}

/* ================== DİL ================== */
function applyLang(){
  const L=t(); $('q').placeholder=L.searchPH; $('go').textContent=L.go;
  $('pickStart').textContent=L.ui.pickStart; $('pickDest').textContent=L.ui.pickDest; $('reset').textContent=L.ui.reset;
  followBtn.textContent = followState ? L.ui.followOn : L.ui.followOff;
  clearRouteBtn.textContent=L.ui.clearRoute; localStorage.setItem('lang',LANG);
}
langSel.value=LANG; langSel.addEventListener('change',()=>{LANG=langSel.value; applyLang();});

/* ================== ARAMA (basit isim/kategori) ================== */
const SYNONYMS = {
  bar:['bar','бар'],
  cafe:['cafe','café','kafe','кафе','kawiarnia'],
  restaurant:['restoran','restaurant','restauracja','ресторан'],
  pool:['havuz','pool','basen','бассейн'],
  spa:['spa','wellness','спа','sauna'],
  shop:['shop','market','sklep','магазин','butik'],
  toilet:['wc','toilet','tuvalet','toaleta','туалет'],
  reception:['reception','resepsiyon','recepcja','ресепшен'],
  beach:['beach','plaj','plaża','пляж'],
  kidsclub:['kids club','mini club','детский клуб','club dziecięcy'],
  elevator:['elevator','lift','asansör','лифт','winda'],
  gate:['gate','kapı','giriş','brama','eingang','ворота'],
  parking:['parking','otopark','parkplatz','парковка'],
  shuttle:['shuttle','servis','bus','autobus','шаттл'],
  gym:['gym','fitness','spor','fitnessstudio','siłownia']
};
const KEYWORD_TO_CAT = (()=>{const m={}; Object.entries(SYNONYMS).forEach(([k,a])=>a.forEach(w=>m[norm(w)]=k)); return m;})();
function detectCategory(qs){
  const nq=norm(qs), dict=I18N[LANG]?.cats||{};
  for(const [k,label] of Object.entries(dict)){ if(norm(label).includes(nq)||nq.includes(norm(label))) return k; }
  return KEYWORD_TO_CAT[nq] || null;
}
q.addEventListener('input', ()=>{
  const val=(q.value||'').trim();
  if(!val){ results.style.display='none'; return; }
  const qn=norm(val), maybeCat=detectCategory(val);
  const hits = allFeats.filter(f=>{
    const p=f.properties||{}; const cat=(p.category||'').toLowerCase();
    if(maybeCat && cat===maybeCat) return true;
    const names=[p.name,p.name_tr,p.name_en,p.name_ru,p.name_de,p.name_pl].filter(Boolean).map(norm);
    if(names.some(n=>n.includes(qn))) return true;
    const ex=[p.desc,p['desc_'+LANG],p.level,p['level_'+LANG],p.hours,p['hours_'+LANG]].filter(Boolean).map(norm);
    return ex.some(d=>d.includes(qn));
  });
  renderResults(hits, maybeCat);
});
function renderResults(list, cat){
  results.innerHTML='';
  const hint=document.createElement('div'); hint.className='hint'; hint.textContent='🔎 Sonuçlardan birine dokun';
  results.appendChild(hint);
  if(cat){
    const feats=allFeats.filter(f=>(f.properties?.category||'').toLowerCase()===cat);
    const div=document.createElement('div'); div.className='item'; div.dataset.fid='__cat__'+cat;
    div.innerHTML=`<span>➤ ${(t().cats?.[cat]||cat)}</span> <small>${feats.length}</small>`;
    results.appendChild(div);
  }
  list.slice(0,80).forEach((f,idx)=>{
    const p=f.properties||{}; const meta=[p.category||'', p.level||'', (f.__src==='indoor'?'Indoor':'Outdoor')].filter(Boolean).join(' · ');
    const div=document.createElement('div'); div.className='item';
    div.dataset.fid = p.fid || `tmp-${idx}`;
    div.dataset.src = f.__src;
    div.innerHTML=`<span>${nameInAnyLang(p)||'(isimsiz)'}</span><small>${meta}</small>`;
    results.appendChild(div);
  });
  results.style.display='block';
}
results.addEventListener('click', (e)=>{
  const item=e.target.closest('.item'); if(!item) return;
  const fid=item.dataset.fid;
  if(fid && fid.startsWith('__cat__')){ results.style.display='none'; return; }
  const f=allFeats.find(x=>x.properties && x.properties.fid===fid);
  if(!f) return;
  const center=coordOfFeature(f);
  document.getElementById('sheet').style.setProperty('--panel-ty','0px');
  showPopup(f, Array.isArray(center)?center:[center.lng,center.lat], true);
  setDestination(Array.isArray(center)?center:[center.lng,center.lat]);
  results.style.display='none';
  goBtn.disabled = !(startCoord || lastKnown);
});

/* ================== KONUM (BLUEDOT) ================== */
if (SIMULATE_ME){
  map.on('load', ()=>{
    setMe(SIM_ME_COORD, SIM_ME_ACC_M);
    followState = true;
    followBtn.textContent = t().ui.followOn;
    map.easeTo({center: SIM_ME_COORD});
  });
} else if ('geolocation' in navigator){
  try{ navigator.geolocation.getCurrentPosition(()=>{},()=>{}, {enableHighAccuracy:true, timeout:10000}); }catch{}
  navigator.geolocation.watchPosition(p=>{
    const accM = Math.round(p.coords.accuracy||999);
    setMe([p.coords.longitude, p.coords.latitude], accM);
  }, (err)=>{ console.warn('geo error',err); }, {enableHighAccuracy:true, maximumAge:0, timeout:15000});
}
followBtn.onclick=()=>{ followState=!followState; followBtn.textContent = followState ? t().ui.followOn : t().ui.followOff; if(followState && lastKnown) map.easeTo({center:lastKnown}); };

/* ================== HEDEF & BAŞLANGIÇ SEÇİMİ ================== */
pickStartBtn.onclick=()=>{ pickMode = pickMode==='start' ? 'none' : 'start'; pickStartBtn.classList.toggle('active', pickMode==='start'); pickDestBtn.classList.remove('active'); };
pickDestBtn.onclick =()=>{ pickMode = pickMode==='dest'  ? 'none' : 'dest';  pickDestBtn.classList.toggle('active',  pickMode==='dest');  pickStartBtn.classList.remove('active'); };
map.on('click', e=>{
  if(pickMode==='start'){
    startCoord=[e.lngLat.lng,e.lngLat.lat];
    map.getSource('start').setData({type:'FeatureCollection',features:[{type:'Feature',geometry:{type:'Point',coordinates:startCoord}}]});
    pickMode='none'; pickStartBtn.classList.remove('active');
    if(destCoord) goBtn.disabled=false;
  }else if(pickMode==='dest'){
    destCoord=[e.lngLat.lng,e.lngLat.lat];
    map.getSource('dest').setData({type:'FeatureCollection',features:[{type:'Feature',geometry:{type:'Point',coordinates:destCoord}}]});
    pickMode='none'; pickDestBtn.classList.remove('active');
    if(startCoord || lastKnown) goBtn.disabled=false;
  }else{
    const feats = map.queryRenderedFeatures(e.point, {layers:['indoor-pts','outdoor-pts','indoor-fill','outdoor-fill','indoor-line','outdoor-line','indoor-fill-outline','outdoor-fill-outline']});
    if(feats && feats[0]) showPopup(feats[0], e.lngLat, true);
  }
});
function setDestination(xy){
  destCoord=xy;
  map.getSource('dest').setData({type:'FeatureCollection',features:[{type:'Feature',geometry:{type:'Point',coordinates:xy}}]});
}

/* ================== ROTA: METRE + SNAP + GEÇİCİ DÜĞÜM ================== */
let ROUTE_GRAPH = null;  // {nodes, adj, idOf, getId(), addEdge(), removeEdge()}
let ROUTES_FC   = null;  // routes.json ham FC (snap için)

function buildRouteGraph(fc){
  ROUTES_FC = fc;
  const nodes = [];
  const idOf  = new Map();   // "lon,lat" -> nodeId
  const adj   = {};          // nodeId -> [{to, w, modes:Set<string>}]

  function key(xy){ return xy[0].toFixed(7)+','+xy[1].toFixed(7); }
  function getId(xy, forceNew=false){
  const k = key(xy);
  if(!forceNew && idOf.has(k)) return idOf.get(k);

  // 👇 BURAYA tolerans ekle
  if(!forceNew){
    const TOL_M = 2.0;  // istersen 2.0 yapabilirsin
    for(let i=0; i<nodes.length; i++){
      const dist = turf.distance(
        turf.point(nodes[i].xy),
        turf.point(xy),
        {units:'meters'}
      );
      if(dist <= TOL_M){
        idOf.set(k, nodes[i].id);
        return nodes[i].id;
      }
    }
  }

  const id = nodes.length;
  idOf.set(k,id);
  nodes.push({id, xy});
  if(!adj[id]) adj[id] = [];
  return id;
}

  function addEdge(aId,bId,w,meta){
    const modes = (meta?.modes || new Set(['walk','bike','shuttle']));
    adj[aId].push({to:bId, w, modes});
    adj[bId].push({to:aId, w, modes});
  }
  function removeEdge(aId,bId){
    adj[aId] = (adj[aId]||[]).filter(e=>e.to!==bId);
    adj[bId] = (adj[bId]||[]).filter(e=>e.to!==aId);
  }

  (fc.features||[]).forEach(f=>{
    if(!f.geometry || f.geometry.type!=='LineString') return;
    const c = f.geometry.coordinates || [];
    const modes = new Set(String(f.properties?.modes||'walk,bike,shuttle').split(/[,\s;]+/).filter(Boolean));
    for(let i=1;i<c.length;i++){
      const aId = getId(c[i-1]);
      const bId = getId(c[i]);
      const w   = meters(c[i-1], c[i]); // METRE
      addEdge(aId, bId, w, {modes});
    }
  });

  ROUTE_GRAPH = { nodes, adj, idOf, getId, addEdge, removeEdge };
}

/* Snap: tüm route çizgilerinde en yakın nokta */
function snapToNetworkAllRoutes(xy){
  if(!ROUTES_FC) return null;
  const pt = turf.point(xy);
  let best = null;

  (ROUTES_FC.features||[]).forEach((f, fi)=>{
    if(!f.geometry || f.geometry.type!=='LineString') return;
    const res = turf.nearestPointOnLine(f, pt, {units:'meters'});
    const idx = res.properties.index;
    const line = f.geometry.coordinates;
    const a = line[Math.max(0, idx)];
    const b = line[Math.min(line.length-1, idx+1)];
    const snap = {
      xy: res.geometry.coordinates,
      a, b,
      modes: new Set(String(f.properties?.modes||'walk,bike,shuttle').split(/[,\s;]+/).filter(Boolean)),
      distM: res.properties.dist,
      featureIndex: fi
    };
    if(!best || snap.distM < best.distM) best = snap;
  });

  return best; // {xy, a, b, modes, ...}
}


/* Geçici düğüm: A–B yi, A–S ve S–B olarak böl */
function insertTempNodeIntoGraph(snap){
  const {xy,a,b,modes} = snap;
  const S   = ROUTE_GRAPH.getId(xy, /*forceNew*/ true);
  const aId = ROUTE_GRAPH.getId(a);
  const bId = ROUTE_GRAPH.getId(b);

  ROUTE_GRAPH.removeEdge(aId, bId);
  ROUTE_GRAPH.addEdge(aId, S, meters(a,xy), {modes});
  ROUTE_GRAPH.addEdge(S,  bId, meters(xy,b), {modes});

  return S;
}

/* Dijkstra: profil filtresi ile */
function dijkstra(startId, endId, profileKey='walk'){
  const allowed = new Set([profileKey]);
  const N = ROUTE_GRAPH.nodes.length, adj = ROUTE_GRAPH.adj;
  const distArr = new Array(N).fill(Infinity);
  const prev    = new Array(N).fill(-1);
  const used    = new Array(N).fill(false);

  distArr[startId] = 0;

  for(let k=0; k<N; k++){
    let u=-1, best=Infinity;
    for(let i=0;i<N;i++) if(!used[i] && distArr[i]<best){ best=distArr[i]; u=i; }
    if(u===-1) break;
    used[u]=true;
    if(u===endId) break;

    for(const e of (adj[u]||[])){
      if(e.modes && ![...e.modes].some(m=>allowed.has(m))) continue;
      const alt = distArr[u] + e.w;
      if(alt < distArr[e.to]){ distArr[e.to]=alt; prev[e.to]=u; }
    }
  }
  if(prev[endId]===-1 && endId!==startId) return null;

  const path=[]; let cur=endId;
  while(cur!==-1){ path.push(cur); if(cur===startId) break; cur=prev[cur]; }
  return path.reverse();
}

/* Rota hesapla (SNAP + geçici düğüm + turn-by-turn + süre/mesafe) */

goBtn.onclick = ()=>{
  closePopup(); // ➜ ekle
  const srcStart = startCoord || lastKnown;
  const srcDest  = destCoord;

  if(!srcDest){ alert(LANG==='tr'?'Hedef seçilmedi.':'No destination.'); return; }
  if(!srcStart){ alert(LANG==='tr'?'Başlangıç seçin ya da konum izni verin.':'Pick a start or allow location.'); return; }
  if(!ROUTE_GRAPH || ROUTE_GRAPH.nodes.length===0){ alert('routes.json yüklenemedi ya da boş.'); return; }

  const Ssnap = snapToNetworkAllRoutes(srcStart);
  const Tsnap = snapToNetworkAllRoutes(srcDest);
  if(!Ssnap || !Tsnap){ alert('Ağa snap edilemedi.'); return; }

  // --- connector mesafeleri
  const usedStart  = startCoord || lastKnown;
  const usedDest   = destCoord;
  const startConnM = usedStart ? meters(usedStart, Ssnap.xy) : 0;
  const destConnM  = usedDest  ? meters(Tsnap.xy,  usedDest)  : 0;

  // --- çok uzaksa iptal
  if (startConnM > MAX_CONNECTOR_M || destConnM > MAX_CONNECTOR_M) {
    alert('Başlangıç veya hedef yol ağından çok uzakta. Lütfen yola yakın bir nokta seçin.');
    updateDebugOverlay({showComps:true, showSnaps:true, showDead:true, snaps:[Ssnap, Tsnap]});
    return;
  }

  // --- graf içine geçici düğümler
  const Sid = insertTempNodeIntoGraph(Ssnap);
  const Tid = insertTempNodeIntoGraph(Tsnap);

  const nodePath = dijkstra(Sid, Tid, CURRENT_PROFILE);
  if(!nodePath){
    printGraphStats();
    logSnap('START', Ssnap); logSnap('DEST', Tsnap);
    const comp = components(); const cS = comp[Sid], cT = comp[Tid];
    const msg = (cS===cT)
      ? 'Uygun rota bulunamadı. (Mod kısıtı olabilir veya snap edilen segmentte hata/uç nokta var.)'
      : `Ağ kopuk: başlangıç bileşeni=${cS}, hedef bileşeni=${cT}. Bağlantı yok.`;
    alert(msg);
    updateDebugOverlay({showComps:true, showSnaps:true, showDead:true, snaps:[Ssnap, Tsnap]});
    return;
  }

  updateDebugOverlay({
    showComps: document.getElementById('dbgComps').checked,
    showSnaps: document.getElementById('dbgSnaps').checked,
    showDead : document.getElementById('dbgDead').checked,
    snaps:[Ssnap, Tsnap]
  });

  // --- geojson features
  const nodeCoords = nodePath.map(id=>ROUTE_GRAPH.nodes[id].xy);
  const features = [
    {type:'Feature', properties:{role:'main'}, geometry:{type:'LineString', coordinates: nodeCoords}}
  ];
  if (usedStart && startConnM >= HIDE_CONNECTOR_LT_M) {
    features.push({type:'Feature', properties:{role:'connector'},
      geometry:{type:'LineString', coordinates:[usedStart, Ssnap.xy]}});
  }
  if (usedDest && destConnM >= HIDE_CONNECTOR_LT_M) {
    features.push({type:'Feature', properties:{role:'connector'},
      geometry:{type:'LineString', coordinates:[Tsnap.xy, usedDest]}});
  }
  map.getSource('route').setData({type:'FeatureCollection', features});

  const mainLenM = totalLength(nodeCoords);
  const totalLenM= mainLenM + (usedStart?meters(usedStart,Ssnap.xy):0) + (usedDest?meters(Tsnap.xy,usedDest):0);
  const durSec   = mainLenM / (SPEEDS[CURRENT_PROFILE] || 1.3);
  dirSum.textContent = fmtDist(totalLenM)+' · '+fmtDur(durSec);
  dirSub.textContent = '· '+CURRENT_PROFILE;

  renderTurnByTurn(nodeCoords);

  // >>> BURAYA EKLE
dirList.style.display = 'none';      // listeyi kapat
collapseDir.textContent = '▼';       // buton oku aşağı olsun
// <<< BURAYA EKLE
  const bb = bboxFromCoords(nodeCoords.concat(usedStart?[usedStart]:[], usedDest?[usedDest]:[]));
  if(bb) map.fitBounds([[bb[0],bb[1]],[bb[2],bb[3]]], {padding:PADDING, maxZoom:18});
  showRouteUI();
};

/* ================== TURN-BY-TURN ================== */
function renderTurnByTurn(coords){
  dirList.innerHTML='';
  if(!coords || coords.length<2) return;

  const L = t().nav;

  // Kalkış
  appendStep(L.depart, 0);

  // İlk segment düz toplamına eklensin
  let accStraightM = meters(coords[0], coords[1]);

  for(let i=1; i<coords.length-1; i++){
    const b1 = turf.bearing(turf.point(coords[i-1]), turf.point(coords[i]));
    const b2 = turf.bearing(turf.point(coords[i]),   turf.point(coords[i+1]));
    const turn = angDiff(b1, b2); // [-180,180]
    const nextSegM = meters(coords[i], coords[i+1]);

    // |turn| < 35° ise düz kabul et, biriktir
    if (Math.abs(turn) < 35){
      accStraightM += nextSegM;
      continue;
    }

    // Dönüş var: önce “toplu düz”ü yaz
    if (accStraightM > 0) {
      appendStep(L.straight, accStraightM);
      accStraightM = 0;
    }

    // Dönüşü yaz (mesafesiz)
    if (turn > 0)      appendStep(L.turn_right, 0);
    else               appendStep(L.turn_left,  0);

    // Dönüşten sonraki segment düz toplamını başlat
    accStraightM = nextSegM;
  }

  // Sonda kalan düz varsa yaz
  if (accStraightM > 0) appendStep(L.straight, accStraightM);

  // Varış
  appendStep(L.arrive, 0);

  function appendStep(text, m){
    const el=document.createElement('div');
    el.className='step';
    el.style.display='grid';
    el.style.gridTemplateColumns='20px 1fr';
    el.style.gap='8px';
    el.style.padding='6px 0';
    el.innerHTML = `<div>•</div><div><div>${text}</div>${m?`<div class="muted" style="font-size:12px">${fmtDist(m)}</div>`:''}</div>`;
    dirList.appendChild(el);
  }
}

/* ================== POPUP ================== */
let popup;
function showPopup(f,lngLat,withGo){
  const p=f.properties||{}, L=t();
  const name = p['name_'+LANG] || p.name || '';
  const catKey=(p.category||'').toLowerCase(); const catLabel=L.cats?.[catKey] || p.category || '';
  const hours = p['hours_'+LANG] || p.hours || ''; const level=p['level_'+LANG]||p.level||'';
  const desc  = p['desc_'+LANG]  || p.desc  || ''; const img  = p['image_'+LANG]||p.image||'';
  const btn = withGo? `<div style="margin-top:8px"><button class="goto-btn" data-x="${Array.isArray(lngLat)?lngLat[0]:lngLat.lng}" data-y="${Array.isArray(lngLat)?lngLat[1]:lngLat.lat}">${L.go||'Git'} ➜</button></div>` : '';
  const html = `<div style="min-width:220px">
      <div style="font-weight:600;margin-bottom:6px;color:#0f5132">${name}</div>
      ${catLabel?`<div class="badge">${catLabel}</div>`:''}
      ${hours?`<div style="margin-top:6px"><small>${L.labels.hours}:</small> ${hours}</div>`:''}
      ${level?`<div><small>${L.labels.level}:</small> ${level}</div>`:''}
      ${desc?`<div style="margin-top:6px" class="muted">${linkify(desc)}</div>`:''}
      ${/^https?:\/\//i.test(img)?`<div style="margin-top:6px"><img src="${img}" alt=""></div>`:''}
      ${btn}
    </div>`;
  (popup||(popup=new maplibregl.Popup({closeButton:true, closeOnClick:true}))).setLngLat(lngLat).setHTML(html).addTo(map);
}
document.addEventListener('click', (e)=>{
  const btn=e.target.closest('.goto-btn'); if(!btn) return;
  const x=parseFloat(btn.dataset.x), y=parseFloat(btn.dataset.y);
  setDestination([x,y]);
  closePopup();
  goBtn.disabled = !(startCoord || lastKnown);
  if(!goBtn.disabled) goBtn.click();
});

/* ================== YARDIMCILAR ================== */
// Metre bazlı mesafe (Turf haversine)
function meters(a, b){
  return turf.distance(turf.point(a), turf.point(b), {units:'meters'});
}
function totalLength(coords){
  let s=0; for(let i=1;i<coords.length;i++) s+=meters(coords[i-1], coords[i]); 
  return s;
}
function fmtDist(m){ return m>=1000 ? (m/1000).toFixed(2)+' km' : Math.round(m)+' m'; }
function fmtDur(sec){
  if(!isFinite(sec)) return '–';
  const m = Math.round(sec/60);
  if(m<60) return m+' dk';
  const h = Math.floor(m/60), mm = m%60;
  return h+' sa '+(mm?mm+' dk':'');
}
// Açı farkını [-180,180] normalize
function angDiff(a,b){ let d=((b-a)%360+540)%360-180; return d; }

// Diğer yardımcılar
function coordOfFeature(f){
  const g=f.geometry; if(!g) return [(HOTEL_BBOX[0]+HOTEL_BBOX[2])/2,(HOTEL_BBOX[1]+HOTEL_BBOX[3])/2];
  if(g.type==='Point') return g.coordinates;
  if(g.type==='Polygon'){ const ring=g.coordinates[0]; return ring[Math.floor(ring.length/2)]; }
  if(g.type==='LineString'){ const c=g.coordinates; return c[Math.floor(c.length/2)]; }
  return [(HOTEL_BBOX[0]+HOTEL_BBOX[2])/2,(HOTEL_BBOX[1]+HOTEL_BBOX[3])/2];
}
function bboxFromCoords(coords){
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  coords.forEach(([x,y])=>{ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; });
  return (isFinite(minX)&&isFinite(minY)&&isFinite(maxX)&&isFinite(maxY))?[minX,minY,maxX,maxY]:null;
}
function showRouteUI(){
  if (results) results.style.display = 'none';
  if (searchRow) searchRow.style.display = 'none';
  if (ctlsRow)   ctlsRow.style.display   = 'none';

  // Rota paneli özet modda açılsın
   showSearchUI();   // ← rota paneli kapansın, arama alanı geri gelsin
  collapseDir.textContent = '▼';

  setMode('route'); 
}

function showSearchUI(){
  dirBox.style.display = 'none';   // rota panelini kapat
  if (searchRow) searchRow.style.display = 'grid'; // arama satırı grid
  if (ctlsRow)   ctlsRow.style.display   = 'flex'; // butonlar flex
}

// Graf özetini consola yaz
function printGraphStats(){
  if(!ROUTE_GRAPH){ console.warn('Graph yok'); return; }
  const N = ROUTE_GRAPH.nodes.length;
  let E = 0, deg1 = 0;
  const deg = new Array(N).fill(0);
  for(let i=0;i<N;i++){
    const d=(ROUTE_GRAPH.adj[i]||[]).length; deg[i]=d; E+=d;
    if(d===1) deg1++;
  }
  E = E/2; // çift yönlü
  const comp = components();
  const compCount = Math.max(...comp)+1;
  console.log('[GRAPH]', {nodes:N, edges:E, deg1, components:compCount});
}

// u->v kenarının metadata'sı
function getEdgeMeta(u,v){
  const list = ROUTE_GRAPH.adj[u]||[];
  return list.find(e=>e.to===v) || null;
}

// Bileşen hesapla
function components(){
  const N = ROUTE_GRAPH.nodes.length;
  const comp = new Array(N).fill(-1);
  let cid=0;
  for(let i=0;i<N;i++){
    if(comp[i]!==-1) continue;
    const q=[i]; comp[i]=cid;
    for(let qi=0; qi<q.length; qi++){
      const u = q[qi];
      for(const e of (ROUTE_GRAPH.adj[u]||[])){
        if(comp[e.to]===-1){ comp[e.to]=cid; q.push(e.to); }
      }
    }
    cid++;
  }
  return comp;
}

// Adj'dan edge feature'ları (bileşen id'li) üret
function makeDebugEdges(comp){
  const seen = new Set();
  const feats=[];
  for(let u=0; u<ROUTE_GRAPH.nodes.length; u++){
    for(const e of (ROUTE_GRAPH.adj[u]||[])){
      const v = e.to; if(u>v) continue; // her kenarı 1 kez
      const key = u+'-'+v; if(seen.has(key)) continue; seen.add(key);
      feats.push({
        type:'Feature',
        properties:{kind:'edge', comp: comp[u]},
        geometry:{type:'LineString', coordinates:[ROUTE_GRAPH.nodes[u].xy, ROUTE_GRAPH.nodes[v].xy]}
      });
    }
  }
  return feats;
}

// Dead-end düğüm noktaları
function makeDeadEnds(){
  const feats=[];
  for(let i=0;i<ROUTE_GRAPH.nodes.length;i++){
    if((ROUTE_GRAPH.adj[i]||[]).length===1){
      feats.push({type:'Feature', properties:{kind:'dead'}, geometry:{type:'Point', coordinates:ROUTE_GRAPH.nodes[i].xy}});
    }
  }
  return feats;
}

// Snap debug (S/T noktaları ve A–B segmentleri)
function makeSnapDebug(snap, label){
  if(!snap) return [];
  const feats=[];
  feats.push({type:'Feature', properties:{kind:'snap', label}, geometry:{type:'Point', coordinates:snap.xy}});
  feats.push({type:'Feature', properties:{kind:'seg', label}, geometry:{type:'LineString', coordinates:[snap.a, snap.b]}});
  return feats;
}

// Toggle'lardan çiz (her çağrıda komple yeniler)
function updateDebugOverlay(opts={}){
  const {showComps, showSnaps, showDead, snaps=[]} = opts;
  const fc = {type:'FeatureCollection', features:[]};
  if(showComps && ROUTE_GRAPH){
    const comp = components();
    fc.features.push(...makeDebugEdges(comp));
  }
  if(showDead && ROUTE_GRAPH){
    fc.features.push(...makeDeadEnds());
  }
  if(showSnaps && snaps.length){
    snaps.forEach((s,i)=> fc.features.push(...makeSnapDebug(s, i===0?'S':'T')));
  }
  map.getSource('debug').setData(fc);
}

// Checkbox değişimleri
['dbgComps','dbgSnaps','dbgDead'].forEach(id=>{
  const el=document.getElementById(id);
  if(el) el.addEventListener('change', ()=>{
    updateDebugOverlay({
      showComps: document.getElementById('dbgComps').checked,
      showSnaps: document.getElementById('dbgSnaps').checked,
      showDead : document.getElementById('dbgDead').checked,
    });
  });
});

// Snap ayrıntılarını consola yaz (teşhis için)
function logSnap(tag, snap){
  if(!snap){ console.warn(tag, 'snap yok'); return; }
  console.log(`[SNAP:${tag}]`, {
    xy: snap.xy,
    distM: snap.distM,
    a: snap.a, b: snap.b,
    featureId: snap.featureId, featureName: snap.featureName
  });
}


/* ================== ROTA PANELİ BUTONLARI ================== */
function clearRoute(){
  map.getSource('route').setData(emptyFC());

  dirList.innerHTML='';
  dirSum.textContent='–';
  dirSub.textContent='';
  setMode('search');               // ➜ rota alanını kapat, search’i aç
}
clearRouteBtn.onclick=()=>clearRoute();
collapseDir.onclick=()=>{ const s=getComputedStyle(dirList).display; dirList.style.display= s==='none' ? 'block':'none'; collapseDir.textContent = s==='none' ? '▲':'▼'; };

/* ================== RESET + POPUP KAPAT ================== */
function closePopup(){ if(popup) popup.remove(); }
resetBtn.onclick=()=>{ 
  closePopup(); clearRoute(); setMode('search');
  map.getSource('dest').setData(emptyFC()); destCoord=null;
  map.getSource('start').setData(emptyFC()); startCoord=null;
  q.value=''; results.style.display='none'; pickMode='none';
  pickStartBtn.classList.remove('active'); pickDestBtn.classList.remove('active');
  document.getElementById('sheet').style.setProperty('--panel-ty','0px');
  map.fitBounds([[HOTEL_BBOX[0],HOTEL_BBOX[1]],[HOTEL_BBOX[2],HOTEL_BBOX[3]]],{padding:PADDING,maxZoom:19,pitch:DEFAULT_PITCH,bearing:DEFAULT_BEARING});
};

/* ================== BLUEDOT (BENİM KONUMUM) ================== */
function setMe(xy, accM=5){
  lastKnown = xy;
  const meSrc = map.getSource('me');
  if (meSrc) {
    meSrc.setData({
      type:'FeatureCollection',
      features:[{type:'Feature', properties:{acc:accM},
        geometry:{type:'Point', coordinates:xy}}]
    });
  }
  acc.textContent = "±"+accM+" m";
  acc.style.display='block';
  if (followState) map.easeTo({center:lastKnown});
  goBtn.disabled = !(startCoord || lastKnown);
}

/* ================== ALT PANEL (AÇ/KAPA SÜRÜKLEME) ================== */
(function(){
  const sheet=$('sheet'), grab=$('grab');
  const H_GRAB=24;
  const setTy=v=> sheet.style.setProperty('--panel-ty',v+'px');
  const getTy=()=> parseFloat(getComputedStyle(sheet).getPropertyValue('--panel-ty'))||0;
  function maxTravel(){
    const h=sheet.getBoundingClientRect().height||320;
    const byH=Math.max(0,h-(H_GRAB+8));
    const byV=Math.min(window.innerHeight*0.6,520);
    return Math.min(byH,byV);
  }
  let MAX=0, sy=null, st=0;
  function recalc(){ MAX=maxTravel(); setTy(Math.min(getTy(),MAX)); }
  window.addEventListener('resize',recalc);
  requestAnimationFrame(()=>{ recalc(); setTy(0); });

  grab.addEventListener('pointerdown',e=>{ sy=e.clientY; st=getTy(); grab.setPointerCapture(e.pointerId); });
  grab.addEventListener('pointermove',e=>{ if(sy==null)return; const dy=e.clientY-sy; setTy(Math.max(0,Math.min(MAX,st+dy))); });
  function end(){ if(sy==null)return; const ty=getTy(); setTy(ty>MAX*0.5?MAX:0); sy=null; }
  grab.addEventListener('pointerup',end); grab.addEventListener('pointercancel',end);
  grab.addEventListener('click',()=>{ const ty=getTy(); setTy(ty===0?MAX:0); });
})();
</script>
</body>
</html>

